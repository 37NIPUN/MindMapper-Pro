<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <title>MindMapper Pro</title>

    <!-- 1. Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- 2. Load React and ReactDOM -->
    <script
      crossorigin
      src="https://unpkg.com/react@18/umd/react.development.js"
    ></script>
    <script
      crossorigin
      src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"
    ></script>

    <!-- 3. Load Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- 4. Load html2canvas -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <style>
      body {
        margin: 0;
        font-family: "Inter", sans-serif;
        overflow: hidden;
      }

      .no-select {
        user-select: none;
      }

      /* High Contrast Cursor */
      .cursor-pan {
        cursor: move;
        cursor: all-scroll;
      }

      .cursor-pan:active {
        cursor: grabbing;
      }

      .cursor-grab-root {
        cursor: move;
        cursor: all-scroll;
      }

      .cursor-grab-root:active {
        cursor: grabbing;
      }

      /* Hide scrollbar for notes area but allow scroll */
      .scrollbar-hide::-webkit-scrollbar {
        display: none;
      }

      .scrollbar-hide {
        -ms-overflow-style: none;
        scrollbar-width: none;
      }

      textarea {
        resize: none;
      }

      /* Dialog Animation */
      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: scale(0.95);
        }

        to {
          opacity: 1;
          transform: scale(1);
        }
      }

      .animate-fade-in {
        animation: fadeIn 0.15s ease-out forwards;
      }

      /* Toast Slide Animation */
      @keyframes slideInRight {
        from {
          transform: translateX(100%);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }

      .animate-slide-in-right {
        animation: slideInRight 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275)
          forwards;
      }
    </style>
  </head>

  <body class="bg-slate-50">
    <div id="root"></div>

    <script type="text/babel">
      const {
        useState,
        useRef,
        useEffect,
        useCallback,
        useMemo,
        useLayoutEffect,
      } = React;

      // --- ICONS ---
      const PlusIcon = () => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="16"
          height="16"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
        >
          <path d="M5 12h14" />
          <path d="M12 5v14" />
        </svg>
      );
      const TrashIcon = () => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="20"
          height="20"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
        >
          <path d="M3 6h18" />
          <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6" />
          <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2" />
        </svg>
      );
      const UploadIcon = () => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="16"
          height="16"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
        >
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
          <polyline points="17 8 12 3 7 8" />
          <line x1="12" x2="12" y1="3" y2="15" />
        </svg>
      );
      const DownloadIcon = () => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="20"
          height="20"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
        >
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
          <polyline points="7 10 12 15 17 10" />
          <line x1="12" x2="12" y1="15" y2="3" />
        </svg>
      );
      const LoaderIcon = () => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="16"
          height="16"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className="animate-spin"
        >
          <path d="M21 12a9 9 0 1 1-6.219-8.56" />
        </svg>
      );
      const ZoomInIcon = () => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="20"
          height="20"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
        >
          <circle cx="11" cy="11" r="8" />
          <line x1="21" y1="21" x2="16.65" y2="16.65" />
          <line x1="11" y1="8" x2="11" y2="14" />
          <line x1="8" y1="11" x2="14" y2="11" />
        </svg>
      );
      const ZoomOutIcon = () => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="20"
          height="20"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
        >
          <circle cx="11" cy="11" r="8" />
          <line x1="21" y1="21" x2="16.65" y2="16.65" />
          <line x1="8" y1="11" x2="14" y2="11" />
        </svg>
      );
      const FitIcon = () => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="20"
          height="20"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
        >
          <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3" />
        </svg>
      );
      const HomeIcon = () => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="20"
          height="20"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
        >
          <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z" />
          <polyline points="9 22 9 12 15 12 15 22" />
        </svg>
      );
      const SaveIcon = () => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="20"
          height="20"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
        >
          <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" />
          <polyline points="17 21 17 13 7 13 7 21" />
          <polyline points="7 3 7 8 15 8" />
        </svg>
      );
      const FolderOpenIcon = () => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="20"
          height="20"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
        >
          <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z" />
        </svg>
      );
      const PaletteIcon = () => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="20"
          height="20"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
        >
          <path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z" />
        </svg>
      );
      const GroupIcon = () => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="20"
          height="20"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
        >
          <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
          <circle cx="9" cy="7" r="4"></circle>
          <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
          <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
        </svg>
      );
      const SingleIcon = () => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="20"
          height="20"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
        >
          <circle cx="12" cy="12" r="10" />
          <circle cx="12" cy="12" r="3" fill="currentColor" />
        </svg>
      );
      const SquareIcon = () => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="20"
          height="20"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
        >
          <rect x="3" y="3" width="18" height="18" rx="2" ry="2" />
        </svg>
      );
      const FilledSquareIcon = () => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="20"
          height="20"
          viewBox="0 0 24 24"
          fill="currentColor"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
        >
          <rect x="3" y="3" width="18" height="18" rx="2" ry="2" />
        </svg>
      );
      const ExpandIcon = () => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="20"
          height="20"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
        >
          <polyline points="7 13 12 18 17 13"></polyline>
          <polyline points="7 6 12 11 17 6"></polyline>
        </svg>
      );
      const MinusCircleIcon = () => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="16"
          height="16"
          viewBox="0 0 24 24"
          fill="white"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
        >
          <circle cx="12" cy="12" r="10" fill="white" />
          <line x1="8" y1="12" x2="16" y2="12" stroke="currentColor" />
        </svg>
      );
      const PlusCircleIcon = () => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="16"
          height="16"
          viewBox="0 0 24 24"
          fill="white"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
        >
          <circle cx="12" cy="12" r="10" fill="white" />
          <line x1="12" y1="8" x2="12" y2="16" stroke="currentColor" />
          <line x1="8" y1="12" x2="16" y2="12" stroke="currentColor" />
        </svg>
      );
      const MapIcon = () => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="24"
          height="24"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
        >
          <circle cx="18" cy="5" r="3"></circle>
          <circle cx="6" cy="12" r="3"></circle>
          <circle cx="18" cy="19" r="3"></circle>
          <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line>
          <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line>
        </svg>
      );
      const NotesIcon = () => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="24"
          height="24"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
        >
          <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
          <polyline points="14 2 14 8 20 8"></polyline>
          <line x1="16" y1="13" x2="8" y2="13"></line>
          <line x1="16" y1="17" x2="8" y2="17"></line>
          <polyline points="10 9 9 9 8 9"></polyline>
        </svg>
      );
      const ArrowUpIcon = () => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="20"
          height="20"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
        >
          <line x1="12" y1="19" x2="12" y2="5"></line>
          <polyline points="5 12 12 5 19 12"></polyline>
        </svg>
      );
      const ArrowDownIcon = () => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="20"
          height="20"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
        >
          <line x1="12" y1="5" x2="12" y2="19"></line>
          <polyline points="19 12 12 19 5 12"></polyline>
        </svg>
      );
      const MoveIcon = () => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="20"
          height="20"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
        >
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
          <polyline points="11 3 16 8 11 13"></polyline>
          <line x1="16" y1="8" x2="3" y2="8"></line>
        </svg>
      );

      const SearchIcon = () => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="20"
          height="20"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
        >
          <circle cx="11" cy="11" r="8"></circle>
          <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
        </svg>
      );
      const CloseIcon = () => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="18"
          height="18"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
        >
          <line x1="18" y1="6" x2="6" y2="18"></line>
          <line x1="6" y1="6" x2="18" y2="18"></line>
        </svg>
      );
      const ChevronLeftIcon = () => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="18"
          height="18"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
        >
          <polyline points="15 18 9 12 15 6"></polyline>
        </svg>
      );
      const ChevronRightIcon = () => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="18"
          height="18"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
        >
          <polyline points="9 18 15 12 9 6"></polyline>
        </svg>
      );

      const EyeIcon = () => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="20"
          height="20"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
        >
          <path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z" />
          <circle cx="12" cy="12" r="3" />
        </svg>
      );

      const ChevronDownSmall = () => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="16"
          height="16"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
        >
          <path d="m6 9 6 6 6-6" />
        </svg>
      );
      const ChevronRightSmall = () => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="16"
          height="16"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
        >
          <path d="m9 18 6-6-6-6" />
        </svg>
      );

      // --- ALIGNMENT ICONS (Simple SVG Helpers) ---
      const AlignLeftIcon = () => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="14"
          height="14"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
        >
          <line x1="17" y1="10" x2="3" y2="10"></line>
          <line x1="21" y1="6" x2="3" y2="6"></line>
          <line x1="21" y1="14" x2="3" y2="14"></line>
          <line x1="17" y1="18" x2="3" y2="18"></line>
        </svg>
      );
      const AlignCenterIcon = () => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="14"
          height="14"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
        >
          <line x1="21" y1="6" x2="3" y2="6"></line>
          <line x1="17" y1="10" x2="7" y2="10"></line>
          <line x1="19" y1="14" x2="5" y2="14"></line>
          <line x1="21" y1="18" x2="3" y2="18"></line>
        </svg>
      );
      const AlignRightIcon = () => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="14"
          height="14"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
        >
          <line x1="21" y1="10" x2="7" y2="10"></line>
          <line x1="21" y1="6" x2="3" y2="6"></line>
          <line x1="21" y1="14" x2="3" y2="14"></line>
          <line x1="21" y1="18" x2="7" y2="18"></line>
        </svg>
      );

      const CopyIcon = () => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="16"
          height="16"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
        >
          <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
          <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
        </svg>
      );

      // --- ICONS (Including MoreOptionsIcon) ---
      const MoreOptionsIcon = () => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="16"
          height="16"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
        >
          <circle cx="12" cy="12" r="1"></circle>
          <circle cx="12" cy="5" r="1"></circle>
          <circle cx="12" cy="19" r="1"></circle>
        </svg>
      );

      // --- NEW ICON: Keyboard ---
      const KeyboardIcon = () => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="20"
          height="20"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
        >
          <rect x="2" y="4" width="20" height="16" rx="2" ry="2"></rect>
          <line x1="6" y1="8" x2="6" y2="8"></line>
          <line x1="10" y1="8" x2="10" y2="8"></line>
          <line x1="14" y1="8" x2="14" y2="8"></line>
          <line x1="18" y1="8" x2="18" y2="8"></line>
          <line x1="6" y1="12" x2="6" y2="12"></line>
          <line x1="10" y1="12" x2="10" y2="12"></line>
          <line x1="14" y1="12" x2="14" y2="12"></line>
          <line x1="18" y1="12" x2="18" y2="12"></line>
          <line x1="6" y1="16" x2="18" y2="16"></line>
        </svg>
      );

      // --- CONSTANTS ---
      const BASE_NODE_WIDTH = 120;
      const MIN_NODE_HEIGHT = 50;
      const HORIZONTAL_GAP = 60;
      const VERTICAL_GAP = 30;
      const SUBTREE_SEPARATION = 60;
      const CHAR_WIDTH_APPROX = 8;

      const COLORS = [
        "#1A237E",
        "#0D47A1",
        "#006064",
        "#1B5E20",
        "#455A64",
        "#5E35B1",
        "#00838F",
        "#EF6C00",
        "#C62828",
        "#6D4C41",
        "#37474F",
      ];

      const FILLED_COLORS = [
        "#E8EAF6",
        "#E3F2FD",
        "#E0F7FA",
        "#E8F5E9",
        "#ECEFF1",
        "#F3E5F5",
        "#E0F2F1",
        "#FFF3E0",
        "#FFEBEE",
        "#EFEBE9",
        "#F5F5F5",
      ];

      // Global default should not depend on a node
      const DEFAULT_COLOR = COLORS[0];

      // Helper to get palette based on style
      const paletteFor = (style) =>
        style === "filled" ? FILLED_COLORS : COLORS;

      // --- NEW COMPONENT: Shortcuts Dialog ---
      const ShortcutsDialog = ({ isOpen, onClose }) => {
        if (!isOpen) return null;

        const shortcuts = [
          {
            category: "Global",
            items: [
              { keys: ["Ctrl", "/"], desc: "Show/Hide Shortcuts" },
              { keys: ["Ctrl", "S"], desc: "Save Project" },
              {
                keys: ["Ctrl", "Shift", "S"],
                desc: "Switch View (Map/Notes)",
              },
              { keys: ["Ctrl", "Shift", "A"], desc: "Add Node / Add Point" },
              { keys: ["Ctrl", "Shift", "D"], desc: "Delete Node / Point" },
              { keys: ["Ctrl", "`"], desc: "Toggle Search Bar" },
            ],
          },
          {
            category: "Mind Map",
            items: [
              { keys: ["Tab"], desc: "Select Next Sibling" },
              {
                keys: ["Ctrl", "Shift", "Arrows"],
                desc: "Move Selection (Up/Down/Left/Right)",
              },
              {
                keys: ["Ctrl", "Shift", "X"],
                desc: "Expand/Collapse Branch",
              },
              { keys: ["Ctrl", "Wheel"], desc: "Zoom In / Out" },
              { keys: ["Drag Canvas"], desc: "Pan View" },
            ],
          },
          {
            category: "Notes Editor",
            items: [
              // NEW: Added Toggle Reading Mode Shortcut
              { keys: ["Ctrl", "Shift", "E"], desc: "Toggle Reading Mode" },
              { keys: ["Tab"], desc: "Insert 4 Spaces" },
              { keys: ["Ctrl", "B"], desc: "Bold Text" },
              { keys: ["Enter"], desc: "New Line / Continue Bullet" },
              { keys: ["Ctrl", "Z"], desc: "Undo" },
              { keys: ["Ctrl", "Y"], desc: "Redo" },
            ],
          },
        ];

        return (
          <div className="fixed inset-0 bg-black/40 backdrop-blur-sm z-[100] flex items-center justify-center p-4 animate-fade-in">
            <div className="bg-white rounded-2xl shadow-2xl w-full max-w-2xl overflow-hidden border border-slate-200">
              {/* Header */}
              <div className="bg-slate-50 px-6 py-4 border-b border-slate-200 flex justify-between items-center">
                <div className="flex items-center gap-2 text-slate-800">
                  <KeyboardIcon />
                  <h2 className="text-xl font-bold">Keyboard Shortcuts</h2>
                </div>
                <button
                  onClick={onClose}
                  className="p-1 hover:bg-red-50 text-slate-400 hover:text-red-500 rounded-full transition-colors"
                >
                  <CloseIcon />
                </button>
              </div>

              {/* Content */}
              <div className="p-6 max-h-[70vh] overflow-y-auto custom-scrollbar">
                <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
                  {shortcuts.map((section) => (
                    <div key={section.category}>
                      <h3 className="text-sm font-bold text-blue-600 uppercase tracking-wider mb-4 border-b border-blue-100 pb-2">
                        {section.category}
                      </h3>
                      <div className="space-y-3">
                        {section.items.map((item, idx) => (
                          <div
                            key={idx}
                            className="flex justify-between items-center text-sm"
                          >
                            <span className="text-slate-600 font-medium">
                              {item.desc}
                            </span>
                            <div className="flex items-center gap-1">
                              {item.keys.map((k, kIdx) => (
                                <kbd
                                  key={kIdx}
                                  className="px-2 py-1 bg-slate-100 border border-slate-300 rounded text-xs font-mono font-bold text-slate-700 shadow-[0_2px_0_#cbd5e1]"
                                >
                                  {k}
                                </kbd>
                              ))}
                            </div>
                          </div>
                        ))}
                      </div>
                    </div>
                  ))}
                </div>
              </div>

              {/* Footer */}
              <div className="bg-slate-50 px-6 py-3 border-t border-slate-200 text-center">
                <p className="text-xs text-slate-400">
                  Pro Tip: Press <kbd className="font-bold">Ctrl + /</kbd> to
                  toggle this menu anytime.
                </p>
              </div>
            </div>
          </div>
        );
      };

      // --- NEW COMPONENT: Move/Copy Dialog ---
      const MoveCopyDialog = ({ isOpen, onClose, onMove, onCopy }) => {
        if (!isOpen) return null;

        return (
          <div className="fixed inset-0 bg-black/40 backdrop-blur-sm z-[100] flex items-center justify-center p-4 animate-fade-in">
            <div className="bg-white rounded-2xl shadow-2xl w-full max-w-sm overflow-hidden border border-slate-200 p-6 text-center">
              <h2 className="text-xl font-bold text-slate-800 mb-2">
                Move or Copy?
              </h2>
              <p className="text-sm text-slate-500 mb-6">
                Do you want to move the original branch or create a copy of it
                under the new parent?
              </p>

              <div className="flex flex-col gap-3">
                <button
                  onClick={onMove}
                  className="w-full py-3 rounded-xl bg-blue-600 hover:bg-blue-700 text-white font-bold transition-all shadow-md hover:shadow-lg flex items-center justify-center gap-2"
                >
                  <MoveIcon /> Move Branch
                </button>
                <button
                  onClick={onCopy}
                  className="w-full py-3 rounded-xl bg-purple-100 hover:bg-purple-200 text-purple-700 font-bold transition-all border border-purple-200 flex items-center justify-center gap-2"
                >
                  <CopyIcon /> Copy Branch
                </button>
                <button
                  onClick={onClose}
                  className="mt-2 w-full py-2 text-sm text-slate-400 hover:text-slate-600 font-medium"
                >
                  Cancel
                </button>
              </div>
            </div>
          </div>
        );
      };

      // --- UPDATED TOAST COMPONENT (Dynamic Width) ---
      const ToastNotification = ({ message, isVisible, onClose }) => {
        useEffect(() => {
          if (isVisible) {
            const timer = setTimeout(() => {
              onClose();
            }, 4000); // Increased time slightly for reading long paths
            return () => clearTimeout(timer);
          }
        }, [isVisible, onClose]);

        if (!isVisible) return null;

        return (
          // Added 'max-w-[90vw]' to prevent it going off-screen on mobile
          // Removed 'max-w-sm' to allow it to grow dynamically
          <div className="fixed bottom-6 right-6 z-[100] animate-slide-in-right max-w-[90vw]">
            <div className="bg-slate-800 text-white px-5 py-4 rounded-xl shadow-2xl flex items-center gap-4 border-l-4 border-green-500 w-auto min-w-[300px]">
              {/* Icon Wrapper */}
              <div className="bg-green-500/20 p-2 rounded-full flex-shrink-0">
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  width="18"
                  height="18"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="#4ade80"
                  strokeWidth="3"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                >
                  <polyline points="20 6 9 17 4 12"></polyline>
                </svg>
              </div>

              {/* Text Content */}
              <div className="flex flex-col flex-1 mr-2">
                <span className="font-bold text-[10px] text-green-400 uppercase tracking-widest mb-0.5">
                  Success
                </span>
                {/* 'whitespace-nowrap' makes it grow horizontally, 'break-words' is fallback */}
                <span className="text-sm font-medium text-slate-100 whitespace-nowrap">
                  {message}
                </span>
              </div>

              {/* Close Button */}
              <button
                onClick={onClose}
                className="p-1 text-slate-400 hover:text-white hover:bg-slate-700/50 rounded-full transition-all flex-shrink-0"
              >
                <CloseIcon />
              </button>
            </div>
          </div>
        );
      };

      // Helper to get correct color based on level and style
      const getColorForLevel = (level, style) => {
        const palette = paletteFor(style);
        return palette[level % palette.length];
      };

      const generateId = () => Math.random().toString(36).substr(2, 9);

      // --- SUB-COMPONENT: Auto Resizing Textarea (Updated for Cursor Tracking) ---
      const AutoTextarea = ({
        id, // <--- NEW PROP
        value,
        onChange,
        onKeyDown,
        onBlur,
        onPaste,
        onCursorTrack, // <--- NEW PROP
        searchQuery,
        isActiveMatch,
        placeholder,
        className,
        style,
        minHeight = "24px",
        autoFocus = false,
      }) => {
        const textareaRef = useRef(null);
        const backdropRef = useRef(null);

        // 1. Focus Logic
        useEffect(() => {
          if (autoFocus && textareaRef.current) {
            textareaRef.current.focus({ preventScroll: true });
            const len = textareaRef.current.value.length;
            textareaRef.current.setSelectionRange(len, len);
          }
        }, []);

        // 2. Height Adjustment & Syncing
        useLayoutEffect(() => {
          const textarea = textareaRef.current;
          if (!textarea) return;

          // FIX: Prevent scroll jumping when resizing
          // We capture the scroll position of the main scroll container before resizing
          // The class ".overflow-y-auto" matches the main NotesView container
          const scrollParent = textarea.closest(".overflow-y-auto");
          const prevScrollTop = scrollParent ? scrollParent.scrollTop : 0;

          textarea.style.height = "auto";
          const newHeight = Math.max(
            textarea.scrollHeight,
            parseInt(minHeight)
          );
          textarea.style.height = `${newHeight}px`;

          if (backdropRef.current) {
            backdropRef.current.style.height = `${newHeight}px`;
          }

          // Restore scroll position if it shifted due to the temporary shrink
          if (scrollParent && scrollParent.scrollTop !== prevScrollTop) {
            scrollParent.scrollTop = prevScrollTop;
          }
        }, [value, minHeight]);

        // 3. Simple Highlight Backdrop Logic (Editing Mode Only)
        const renderBackdrop = () => {
          if (!searchQuery || !value) return value;

          const safeQuery = searchQuery.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
          const regex = new RegExp(`(${safeQuery})`, "gi");
          const parts = value.split(regex);

          return parts.map((part, i) => {
            if (part.toLowerCase() === searchQuery.toLowerCase()) {
              return (
                <mark
                  key={i}
                  className={`rounded-sm transition-colors ${
                    isActiveMatch ? "bg-yellow-400" : "bg-yellow-100"
                  }`}
                  style={{ color: "transparent" }}
                >
                  {part}
                </mark>
              );
            }
            return <span key={i}>{part}</span>;
          });
        };

        return (
          <div className="relative w-full h-full">
            {/* BACKDROP */}
            <div
              ref={backdropRef}
              aria-hidden="true"
              className={`${className} absolute top-0 left-0 w-full pointer-events-none whitespace-pre-wrap break-words overflow-hidden select-none`}
              style={{
                ...style,
                color: "transparent",
                borderColor: "transparent",
                zIndex: 0,
              }}
            >
              {renderBackdrop()}
            </div>

            {/* MAIN TEXTAREA */}
            <textarea
              id={id} // <--- Pass ID to DOM
              ref={textareaRef}
              value={value}
              onChange={onChange}
              onKeyDown={onKeyDown}
              onBlur={onBlur}
              onPaste={onPaste}
              // NEW: Track cursor on click or selection change
              onSelect={(e) =>
                onCursorTrack && onCursorTrack(e.target.selectionStart)
              }
              placeholder={placeholder}
              className={`${className} relative z-10 bg-transparent`}
              style={{
                ...style,
                overflow: "hidden",
                caretColor: "black",
              }}
              rows={1}
            />
          </div>
        );
      };

      // --- SUB-COMPONENT: Map Renderer (Updated with LaTeX Export Support) ---
      const MapRenderer = ({
        nodes,
        selectedNodeId,
        updateNodeText,
        onNodeClick,
        onNodeMouseDown,
        onToggleCollapse,
        dirtyLevel1Nodes = new Set(),
        isExport = false,
        disableAutoFocus = false, // <--- NEW PROP
      }) => {
        // ... (renderSvgText helper remains the same) ...
        const renderSvgText = (text, keyBase) => {
          if (!text) return null;
          const regex =
            /(\*\*.*?\*\*|\^\{[^}]+\}|\^[\w\d\+\-\=]|\_\{[^}]+\}|\_[\w\d\+\-\=])/g;
          const parts = text.split(regex);

          return parts.map((part, i) => {
            const key = `${keyBase}-${i}`;
            if (part.startsWith("**") && part.endsWith("**")) {
              return (
                <tspan key={key} fontWeight="bold">
                  {renderSvgText(part.slice(2, -2), key)}
                </tspan>
              );
            }
            if (part.startsWith("^")) {
              const content = part.startsWith("^{")
                ? part.slice(2, -1)
                : part.slice(1);
              return (
                <tspan key={key} baselineShift="super" fontSize="75%">
                  {renderSvgText(content, key)}
                </tspan>
              );
            }
            if (part.startsWith("_")) {
              const content = part.startsWith("_{")
                ? part.slice(2, -1)
                : part.slice(1);
              return (
                <tspan key={key} baselineShift="sub" fontSize="75%">
                  {renderSvgText(content, key)}
                </tspan>
              );
            }
            return <tspan key={key}>{part}</tspan>;
          });
        };

        // NEW: Handle KeyDown for Bold Shortcut in Map Nodes
        const handleKeyDown = (e, nodeId, currentText) => {
          if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "b") {
            e.preventDefault();
            const textarea = e.target;
            const start = textarea.selectionStart;
            const end = textarea.selectionEnd;
            const selection = currentText.substring(start, end);

            let newText;
            let newCursorPos;

            if (selection) {
              // Wrap selection with **
              newText =
                currentText.substring(0, start) +
                "**" +
                selection +
                "**" +
                currentText.substring(end);
              newCursorPos = end + 4; // Place cursor after the closing **
            } else {
              // No selection: Insert **** and place cursor in middle
              newText =
                currentText.substring(0, start) +
                "****" +
                currentText.substring(end);
              newCursorPos = start + 2;
            }

            updateNodeText(nodeId, newText);

            // Restore cursor position after render
            setTimeout(() => {
              const el = document.getElementById(`node-input-${nodeId}`);
              if (el) {
                el.selectionStart = el.selectionEnd = newCursorPos;
              }
            }, 0);
          }
        };

        return (
          <g>
            {/* Lines (Unchanged) */}
            {nodes.map((node) => {
              if (!node.parentId) return null;
              const parent = nodes.find((n) => n.id === node.parentId);
              if (!parent) return null;

              const startX = parent.x + parent.width;
              const startY = parent.y + parent.height / 2;
              const endX = node.x;
              const endY = node.y + node.height / 2;

              const c1x = startX + (endX - startX) / 2;
              const c1y = startY;
              const c2x = startX + (endX - startX) / 2;
              const c2y = endY;

              return (
                <path
                  key={`edge-${node.id}`}
                  d={`M ${startX} ${startY} C ${c1x} ${c1y}, ${c2x} ${c2y}, ${endX} ${endY}`}
                  fill="none"
                  stroke={node.color}
                  strokeWidth="2"
                />
              );
            })}

            {/* Nodes */}
            {nodes.map((node) => {
              const isRoot = node.id === "root";
              const isFilled = node.style === "filled";
              const nodeColor = node.color || COLORS[0];
              const textColor = "#212121";
              const isDirtyLevel1 = !isExport && dirtyLevel1Nodes.has(node.id);
              const isSelected = selectedNodeId === node.id;

              // Shared Style Object
              const commonTextStyle = {
                fontSize: "14px",
                fontWeight: 500,
                lineHeight: "1.4",
                fontFamily: '"Inter", sans-serif',
                padding: "12px 8px 12px 8px",
                color: isFilled ? "white" : "#212121",
                width: "100%",
                height: "100%",
                boxSizing: "border-box",
                overflow: "hidden",
                whiteSpace: "pre-wrap",
                wordBreak: "break-word",
                textAlign: "left",
              };

              if (isExport) {
                return (
                  <g
                    key={node.id}
                    transform={`translate(${node.x}, ${node.y})`}
                  >
                    <rect
                      width={node.width}
                      height={node.height}
                      rx="6"
                      ry="6"
                      fill={isFilled ? nodeColor : "white"}
                      stroke={isFilled ? "none" : nodeColor}
                      strokeWidth={isFilled ? 0 : 2}
                    />
                    {!isFilled && (
                      <path
                        d={`M ${6} ${0} L ${6} ${node.height} L ${4} ${
                          node.height
                        } A 4 4 0 0 1 0 ${
                          node.height - 4
                        } L 0 ${4} A 4 4 0 0 1 4 0 Z`}
                        fill={nodeColor}
                      />
                    )}
                    {node.text.split("\n").map((line, i) => (
                      <text
                        key={i}
                        x={isFilled ? 12 : 18}
                        y={24 + i * 18}
                        fontSize="14"
                        fill={isFilled ? "white" : textColor}
                        fontFamily="Inter, sans-serif"
                      >
                        {renderSvgText(line, i)}
                      </text>
                    ))}
                  </g>
                );
              }

              return (
                <foreignObject
                  key={node.id}
                  x={node.x}
                  y={node.y}
                  width={node.width + 20}
                  height={node.height}
                  className="overflow-visible pointer-events-auto"
                >
                  <div className="relative w-full h-full">
                    <div
                      onMouseDown={(e) =>
                        isRoot && onNodeMouseDown && onNodeMouseDown(e, node.id)
                      }
                      onClick={(e) => onNodeClick && onNodeClick(node.id, e)}
                      className={`
                        absolute left-0 top-0
                        h-full rounded-md shadow-sm flex items-center justify-start
                        transition-all duration-200 relative group
                        ${
                          isSelected
                            ? "ring-2 ring-offset-2 ring-blue-400 scale-105"
                            : ""
                        }
                        ${
                          isDirtyLevel1
                            ? "ring-2 ring-red-500 shadow-[0_0_10px_rgba(239,68,68,0.4)]"
                            : "hover:shadow-md"
                        }
                        ${
                          isRoot
                            ? "cursor-grab-root active:cursor-grabbing"
                            : ""
                        }
                      `}
                      style={{
                        width: node.width,
                        backgroundColor: isFilled ? nodeColor : "white",
                        borderLeft: isFilled
                          ? "none"
                          : `6px solid ${nodeColor}`,
                        borderTop: isDirtyLevel1
                          ? "2px solid #ef4444"
                          : isFilled
                          ? "none"
                          : `2px solid ${nodeColor}`,
                        borderRight: isDirtyLevel1
                          ? "2px solid #ef4444"
                          : isFilled
                          ? "none"
                          : `2px solid ${nodeColor}`,
                        borderBottom: isDirtyLevel1
                          ? "2px solid #ef4444"
                          : isFilled
                          ? "none"
                          : `2px solid ${nodeColor}`,
                      }}
                    >
                      {isSelected ? (
                        <textarea
                          id={`node-input-${node.id}`}
                          value={node.text}
                          placeholder={node.text === "" ? "New Idea" : ""}
                          onChange={(e) =>
                            updateNodeText(node.id, e.target.value)
                          }
                          // ADDED: onKeyDown handler
                          onKeyDown={(e) =>
                            handleKeyDown(e, node.id, node.text)
                          }
                          // UPDATED: Ref Logic to respect disableAutoFocus
                          ref={(el) => {
                            if (
                              el &&
                              !disableAutoFocus &&
                              document.activeElement !== el
                            ) {
                              el.focus();
                              // Move cursor to end
                              el.setSelectionRange(
                                el.value.length,
                                el.value.length
                              );
                            }
                          }}
                          className={`bg-transparent focus:outline-none resize-none no-select ${
                            isRoot ? "cursor-grab-root" : ""
                          }`}
                          style={{
                            ...commonTextStyle,
                            paddingTop: "12px",
                            margin: 0,
                            border: "none",
                            outline: "none",
                          }}
                        />
                      ) : (
                        <div
                          className="pointer-events-none"
                          style={{
                            ...commonTextStyle,
                            display: "block",
                          }}
                        >
                          {parseStyledText(
                            node.text || (node.text === "" ? "New Idea" : ""),
                            "",
                            false
                          )}
                        </div>
                      )}
                    </div>

                    {/* Toggle Button */}
                    {node.hasChildren && (
                      <div
                        className="absolute -right-2 top-1/2 transform -translate-y-1/2 translate-x-full cursor-pointer hover:scale-110 z-50 bg-white rounded-full"
                        onClick={(e) => {
                          e.stopPropagation();
                          onToggleCollapse(node.id);
                        }}
                        style={{
                          color: nodeColor,
                          width: "16px",
                          height: "16px",
                        }}
                      >
                        {node.isCollapsed ? (
                          <PlusCircleIcon />
                        ) : (
                          <MinusCircleIcon />
                        )}
                      </div>
                    )}
                  </div>
                </foreignObject>
              );
            })}
          </g>
        );
      };

      // --- UPDATED: HELPER: Parse Bold, Subscript, Superscript (Fixed Alignment) ---
      const parseRichText = (text, baseIndex) => {
        if (!text) return null;

        // Regex to capture: **bold**, ^{super}, ^char, _{sub}, _char
        const regex =
          /(\*\*.*?\*\*|\^\{[^}]+\}|\^[\w\d\+\-\=]|\_\{[^}]+\}|\_[\w\d\+\-\=])/g;
        const subParts = text.split(regex);

        return subParts.map((subPart, subIndex) => {
          const key = `${baseIndex}-${subIndex}`;

          // Bold: **text**
          if (subPart.startsWith("**") && subPart.endsWith("**")) {
            return (
              <strong key={key} className="font-bold">
                {parseRichText(subPart.slice(2, -2), key)}
              </strong>
            );
          }
          // Superscript: ^{text} or ^t
          if (subPart.startsWith("^")) {
            const content = subPart.startsWith("^{")
              ? subPart.slice(2, -1)
              : subPart.slice(1);
            return (
              <span
                key={key}
                style={{
                  fontSize: "0.75em",
                  position: "relative",
                  top: "-0.4em", // Controls how high it goes (negative moves up)
                  lineHeight: "0",
                  verticalAlign: "baseline",
                }}
              >
                {parseRichText(content, key)}
              </span>
            );
          }
          // Subscript: _{text} or _t
          if (subPart.startsWith("_")) {
            const content = subPart.startsWith("_{")
              ? subPart.slice(2, -1)
              : subPart.slice(1);
            return (
              <span
                key={key}
                style={{
                  fontSize: "0.75em",
                  position: "relative",
                  bottom: "-0.25em", // Controls how low it goes (negative moves down)
                  lineHeight: "0",
                  verticalAlign: "baseline",
                }}
              >
                {parseRichText(content, key)}
              </span>
            );
          }

          // Plain text
          return <span key={key}>{subPart}</span>;
        });
      };

      // --- HELPER: Parse Rich Text & Search Highlights (Combines Logic) ---
      const parseStyledText = (text, searchQuery, isCurrentBlock) => {
        if (!text) return "";

        // 1. Search Highlighting Logic
        if (searchQuery) {
          const safeQuery = searchQuery.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
          const regex = new RegExp(`(${safeQuery})`, "gi");
          const parts = text.split(regex);

          return parts.map((part, index) => {
            if (part.toLowerCase() === searchQuery.toLowerCase()) {
              const isActive = isCurrentBlock;
              return (
                <mark
                  key={index}
                  className={`rounded px-0.5 transition-all inline-block border-b-2 ${
                    isActive
                      ? "bg-orange-400 text-white font-bold border-orange-600 scale-110 shadow-sm z-10 mx-0.5"
                      : "bg-yellow-200 text-slate-800 border-yellow-400"
                  }`}
                >
                  {part}
                </mark>
              );
            }
            // Recursively parse rich text inside non-highlighted parts
            return parseRichText(part, index);
          });
        }

        // 2. Just Rich Text Parsing (No Search)
        return parseRichText(text, 0);
      };

      // --- MAIN PARSER: Handles Bullets + Code Blocks + Syntax Highlighting ---
      const parseMarkdown = (
        text,
        searchQuery = "",
        isCurrentBlock = false,
        isExport = false
      ) => {
        if (!text) return "";

        // 1. HELPER: Aggressive Syntax Highlighter
        const highlightSyntax = (code, lang) => {
          const baseStyle = { color: "#24292e" };
          const tokenTypes = [
            // PRIORITY 1: RICH TEXT (Latex-like Superscript/Subscript/Bold)
            {
              type: "richtext",
              regex:
                /(\*\*.*?\*\*|\^\{[^}]+\}|\^[\w\d\+\-\=]|\_\{[^}]+\}|\_[\w\d\+\-\=])/g,
              style: {},
            },
            {
              type: "comment",
              regex: /(\/\/.*$|#.*$|\/\*[\s\S]*?\*\/)/gm,
              style: { color: "#6a737d", fontStyle: "italic" },
            },
            {
              type: "string",
              regex: /(".*?"|'.*?'|`.*?`)/g,
              style: { color: "#032f62" },
            },
            {
              type: "keyword",
              regex:
                /\b(const|let|var|function|return|if|else|for|while|class|import|from|export|default|async|await|try|catch|new|this|typeof|void|debugger|def|print|break|continue|public|private|static|int|char|float|double|boolean|String|namespace|using|struct|include|extends|implements|interface|package|throws|switch|case|enum)\b/g,
              style: { color: "#d73a49", fontWeight: "bold" },
            },
            {
              type: "boolean",
              regex: /\b(true|false|null|undefined|None|True|False)\b/g,
              style: { color: "#005cc5" },
            },
            {
              type: "number",
              regex: /\b\d+(\.\d+)?\b/g,
              style: { color: "#005cc5" },
            },
            {
              type: "function",
              regex: /\b([a-zA-Z_]\w*)(?=\()/g,
              style: { color: "#6f42c1" },
            },
            {
              type: "class",
              regex: /\b([A-Z][a-zA-Z0-9_]*)\b(?!@)/g,
              style: { color: "#e36209" },
            },
          ];

          let tokens = [];
          let mask = code;

          const saveToken = (type, content, style) => {
            tokens.push({ type, content, style });
            return `@@@TOKEN_${tokens.length - 1}@@@`;
          };

          tokenTypes.forEach((tokenRule) => {
            mask = mask.replace(tokenRule.regex, (match) =>
              saveToken(tokenRule.type, match, tokenRule.style)
            );
          });

          const restoreNestedTokens = (content, keyBase) => {
            const parts = content.split(/(@{3}TOKEN_\d+@{3})/g);
            return parts.map((part, i) => {
              const match = part.match(/^@{3}TOKEN_(\d+)@{3}$/);
              if (match) {
                const token = tokens[parseInt(match[1])];
                if (token.type === "richtext") {
                  return (
                    <span key={`${keyBase}-${i}`}>
                      {parseRichText(token.content, `${keyBase}-${i}`)}
                    </span>
                  );
                }
                return token.content;
              }
              return part;
            });
          };

          const subParts = mask.split(/(@{3}TOKEN_\d+@{3})/g);

          return subParts.map((part, i) => {
            const tokenMatch = part.match(/^@{3}TOKEN_(\d+)@{3}$/);
            if (tokenMatch) {
              const token = tokens[parseInt(tokenMatch[1])];
              if (token.type === "richtext") {
                return <span key={i}>{parseRichText(token.content, i)}</span>;
              }
              return (
                <span key={i} style={token.style}>
                  {restoreNestedTokens(token.content, i)}
                </span>
              );
            }
            return (
              <span key={i} style={baseStyle}>
                {parseRichText(part, 0)}
              </span>
            );
          });
        };

        // 2. HELPER: Render a single code block
        const renderCodeBlock = (rawBlock, key) => {
          const isMultiLine = rawBlock.includes("\n");
          let cleanCode = rawBlock;
          let lang = null;

          if (isMultiLine) {
            const firstLineMatch = rawBlock.match(/^```([a-zA-Z0-9+#.-]+)?/);
            const potentialLang = firstLineMatch ? firstLineMatch[1] : null;
            const validLangs = [
              "js",
              "javascript",
              "jsx",
              "ts",
              "typescript",
              "tsx",
              "html",
              "css",
              "scss",
              "less",
              "json",
              "xml",
              "yaml",
              "yml",
              "markdown",
              "md",
              "txt",
              "text",
              "py",
              "python",
              "java",
              "c",
              "cpp",
              "c++",
              "cs",
              "csharp",
              "go",
              "rust",
              "swift",
              "php",
              "rb",
              "ruby",
              "sql",
              "bash",
              "sh",
              "shell",
              "powershell",
              "ps1",
              "zsh",
              "r",
              "dart",
              "kotlin",
              "lua",
              "perl",
              "scala",
              "groovy",
            ];

            if (
              potentialLang &&
              validLangs.includes(potentialLang.toLowerCase())
            ) {
              lang = potentialLang;
              cleanCode = rawBlock
                .replace(/^```([a-zA-Z0-9+#.-]+)?/, "")
                .replace(/```$/, "")
                .replace(/^\n/, "")
                .replace(/\n$/, "");
            } else {
              cleanCode = rawBlock.replace(/^```/, "").replace(/```$/, "");
            }
          } else {
            // NEW LOGIC: Handle both triple (```) and single (`) backticks inline
            if (rawBlock.startsWith("```")) {
              cleanCode = rawBlock.replace(/^```/, "").replace(/```$/, "");
            } else if (rawBlock.startsWith("`")) {
              cleanCode = rawBlock.replace(/^`/, "").replace(/`$/, "");
            } else {
              // Fallback
              cleanCode = rawBlock.replace(/^```/, "").replace(/```$/, "");
            }
          }

          const highlightedContent = highlightSyntax(cleanCode, lang);

          return (
            <div
              key={key}
              className={`rounded-md shadow-sm relative group overflow-hidden custom-scrollbar ${
                isMultiLine
                  ? "block w-fit max-w-full my-2"
                  : "inline-block align-baseline mx-1 mb-0.5"
              }`}
              style={{
                backgroundColor: "#f6f8fa",
                border: "1px solid #d0d7de",
                borderRadius: "4px",
                padding: isMultiLine ? "12px 16px" : "1px 6px 3px 6px",
                lineHeight: "1.45",
                boxSizing: "border-box",
                verticalAlign: isMultiLine ? "initial" : "middle",
              }}
            >
              <code
                className="font-mono text-[0.85rem]"
                style={{
                  fontFamily:
                    "ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace",
                  color: "#24292e",
                  display: isMultiLine ? "block" : "inline",
                  whiteSpace: "pre-wrap",
                  wordBreak: "break-word",
                  overflowWrap: "anywhere",
                  marginBottom: isMultiLine ? "0" : "1px",
                }}
              >
                {highlightedContent}
              </code>
            </div>
          );
        };

        // 3. LOGIC: Tokenize and Group by Lines
        const rawParts = text.split(/(```[\s\S]*?```)/g);
        const lines = [];
        let currentLine = [];

        // NEW HELPER: Parse inline text for single backticks (`code`)
        const parseAndPush = (str) => {
          if (!str) return;
          // Split by single backticks, excluding newlines to be safe
          const parts = str.split(/(`[^`\n]+`)/g);
          parts.forEach((p) => {
            if (!p) return;
            if (p.startsWith("`") && p.endsWith("`") && p.length > 1) {
              currentLine.push({ type: "code_inline", content: p });
            } else {
              currentLine.push({ type: "text", content: p });
            }
          });
        };

        rawParts.forEach((part) => {
          if (part.startsWith("```") && part.endsWith("```")) {
            const isMultiLine = part.includes("\n");
            if (isMultiLine) {
              if (currentLine.length > 0) {
                lines.push(currentLine);
                currentLine = [];
              }
              lines.push([{ type: "code_block", content: part }]);
            } else {
              // Triple backticks on one line? Treat as code
              currentLine.push({ type: "code_inline", content: part });
            }
          } else {
            const subLines = part.split("\n");

            if (subLines[0] !== "") {
              // Modified: Use parseAndPush instead of direct push
              parseAndPush(subLines[0]);
            }

            for (let i = 1; i < subLines.length; i++) {
              lines.push(currentLine);
              currentLine = [];
              if (subLines[i] !== "") {
                // Modified: Use parseAndPush here too
                parseAndPush(subLines[i]);
              }
            }
          }
        });

        if (currentLine.length > 0) {
          lines.push(currentLine);
        }

        // 4. RENDER
        return (
          <div className="inline-block w-full">
            {lines.map((line, lineIdx) => {
              if (line.length === 0) return <br key={lineIdx} />;

              // --- HEADING DETECTION LOGIC ---
              let isHeading = false;
              let headingLevel = 0;
              let headingContent = line;

              if (line[0].type === "text") {
                const match = line[0].content.match(/^(#{1,6})\s+(.*)/);
                if (match) {
                  isHeading = true;
                  headingLevel = match[1].length;
                  const cleanFirstSegment = { ...line[0], content: match[2] };
                  headingContent = [cleanFirstSegment, ...line.slice(1)];
                } else if (line[0].content.match(/^(#{1,6})\s*$/)) {
                  isHeading = true;
                  headingLevel = line[0].content.trim().length;
                  headingContent = [{ ...line[0], content: "" }];
                }
              }

              if (isHeading) {
                const sizes = {
                  1: "text-3xl font-extrabold mt-6 mb-3 border-b pb-1 border-slate-200 text-slate-900",
                  2: "text-2xl font-bold mt-5 mb-2 text-slate-800",
                  3: "text-xl font-bold mt-4 mb-2 text-slate-800",
                  4: "text-lg font-semibold mt-3 mb-1 text-slate-700",
                  5: "text-base font-semibold mt-2 text-slate-700",
                  6: "text-sm font-semibold uppercase text-slate-500 tracking-wide",
                };
                return (
                  <div
                    key={lineIdx}
                    className={sizes[headingLevel] || sizes[6]}
                  >
                    {headingContent.map((segment, segIdx) => {
                      if (segment.type === "text") {
                        return (
                          <span key={segIdx}>
                            {parseStyledText(
                              segment.content,
                              searchQuery,
                              isCurrentBlock
                            )}
                          </span>
                        );
                      }
                      return renderCodeBlock(segment.content, segIdx);
                    })}
                  </div>
                );
              }

              const prevLine = lineIdx > 0 ? lines[lineIdx - 1] : null;
              // Update prevLine check to handle indentation logic for bullets
              const isPrevBullet =
                prevLine &&
                prevLine.length > 0 &&
                prevLine[0].type === "text" &&
                prevLine[0].content.match(/^\s*(\*|-)\s/);

              if (line.length === 1 && line[0].type === "code_block") {
                return (
                  <div
                    key={lineIdx}
                    className={`my-2 ${isPrevBullet ? "ml-6" : "w-full"}`}
                  >
                    {renderCodeBlock(line[0].content, 0)}
                  </div>
                );
              }

              // --- UPDATED BULLET LOGIC (Supports Indentation) ---
              let isBullet = false;
              let indentLevel = 0;

              if (line[0].type === "text") {
                // Match Leading Spaces (Group 1), Bullet (Group 2), Content (Group 3)
                const match = line[0].content.match(/^(\s*)(\*|-)\s+(.*)/);
                if (match) {
                  isBullet = true;
                  // Calculate indent level: 2 spaces = 1 level
                  indentLevel = Math.floor(match[1].length / 2);
                }
              }

              if (isBullet) {
                const bulletStyles = ["", "", ""];
                const bulletChar = bulletStyles[indentLevel % 3];

                return (
                  <div
                    key={lineIdx}
                    className="flex items-start gap-2 mb-1"
                    // Dynamic margin based on indent level
                    style={{ marginLeft: `${0.25 + indentLevel * 1.5}rem` }}
                  >
                    <span className="text-blue-500 font-bold text-lg leading-none mt-[6px]">
                      {bulletChar}
                    </span>
                    <span
                      className="flex-1 text-slate-700 pt-[2px] break-words"
                      style={{ lineHeight: "1.625" }}
                    >
                      {line.map((segment, segIdx) => {
                        if (segment.type === "text") {
                          const text =
                            segIdx === 0
                              ? segment.content.replace(/^(\s*)(\*|-)\s+/, "")
                              : segment.content;
                          return (
                            <span key={segIdx}>
                              {parseStyledText(
                                text,
                                searchQuery,
                                isCurrentBlock
                              )}
                            </span>
                          );
                        }
                        return renderCodeBlock(segment.content, segIdx);
                      })}
                    </span>
                  </div>
                );
              } else {
                return (
                  <div
                    key={lineIdx}
                    className="text-slate-800 leading-relaxed break-words min-h-[1.4em]"
                  >
                    {line.map((segment, segIdx) => {
                      if (segment.type === "text") {
                        return (
                          <span key={segIdx}>
                            {parseStyledText(
                              segment.content,
                              searchQuery,
                              isCurrentBlock
                            )}
                          </span>
                        );
                      }
                      return renderCodeBlock(segment.content, segIdx);
                    })}
                  </div>
                );
              }
            })}
          </div>
        );
      };

      // --- SUB-COMPONENT: Table Editor (Restored Beautiful Layout + Dropdown) ---
      const TableEditor = ({
        data,
        isReadOnly,
        onUpdate,
        searchQuery,
        isExport,
        onCopy,
        onDelete,
        isHighlighted,
      }) => {
        const headers = data?.headers || ["Header 1", "Header 2"];
        const rows = data?.rows || [
          ["", ""],
          ["", ""],
        ];
        const headerHeight = data?.headerHeight || null;
        const headerAligns = data?.headerAligns || headers.map(() => "left");
        const colAligns = data?.colAligns || headers.map(() => "left");
        const title = data?.title || "";

        // State for active dropdown
        const [activeDropdown, setActiveDropdown] = useState(null);

        // --- HELPERS ---
        const getAlignClass = (align) => {
          switch (align) {
            case "center":
              return "text-center";
            case "right":
              return "text-right";
            default:
              return "text-left";
          }
        };

        const getAlignIcon = (align) => {
          switch (align) {
            case "center":
              return <AlignCenterIcon />;
            case "right":
              return <AlignRightIcon />;
            default:
              return <AlignLeftIcon />;
          }
        };

        // Close dropdown on click outside
        useEffect(() => {
          const handleClickOutside = (event) => {
            if (
              activeDropdown !== null &&
              !event.target.closest(".header-dropdown-container")
            ) {
              setActiveDropdown(null);
            }
          };
          document.addEventListener("mousedown", handleClickOutside);
          return () =>
            document.removeEventListener("mousedown", handleClickOutside);
        }, [activeDropdown]);

        const updateData = (updates) => onUpdate({ ...data, ...updates });

        const handleHeaderChange = (idx, val) => {
          const newHeaders = [...headers];
          newHeaders[idx] = val;
          updateData({ headers: newHeaders });
        };

        const handleCellChange = (rIdx, cIdx, val) => {
          const newRows = [...rows];
          newRows[rIdx] = [...newRows[rIdx]];
          newRows[rIdx][cIdx] = val;
          updateData({ rows: newRows });
        };

        const addColumn = () => {
          updateData({
            headers: [...headers, "New"],
            rows: rows.map((r) => [...r, ""]),
            colWidths: [...(data.colWidths || headers.map(() => 150)), 150],
            headerAligns: [...headerAligns, "left"],
            colAligns: [...colAligns, "left"],
          });
        };

        const addRow = () =>
          updateData({ rows: [...rows, new Array(headers.length).fill("")] });

        const deleteColumn = (colIdx) => {
          if (headers.length <= 1) return;
          updateData({
            headers: headers.filter((_, i) => i !== colIdx),
            rows: rows.map((r) => r.filter((_, i) => i !== colIdx)),
            colWidths: (data.colWidths || headers.map(() => 150)).filter(
              (_, i) => i !== colIdx
            ),
            headerAligns: headerAligns.filter((_, i) => i !== colIdx),
            colAligns: colAligns.filter((_, i) => i !== colIdx),
          });
          setActiveDropdown(null);
        };

        const deleteRow = (rowIdx) => {
          if (rows.length <= 1) return;
          updateData({ rows: rows.filter((_, i) => i !== rowIdx) });
        };

        const setHeaderAlign = (idx, align) => {
          const newAligns = [...headerAligns];
          newAligns[idx] = align;
          updateData({ headerAligns: newAligns });
        };

        const setColAlign = (idx, align) => {
          const newAligns = [...colAligns];
          newAligns[idx] = align;
          updateData({ colAligns: newAligns });
        };

        // --- Resize Handlers ---
        const handleHeaderResizeStart = (e) => {
          if (isReadOnly || isExport) return;
          e.preventDefault();
          e.stopPropagation();
          const startY = e.clientY;
          const startHeight = headerHeight || "auto";
          const initialH = e.target.parentElement.offsetHeight; // Get current visual height

          const onMouseMove = (moveEvent) => {
            const diff = moveEvent.clientY - startY;
            const newHeight = Math.max(30, initialH + diff);
            updateData({ headerHeight: newHeight });
          };

          const onMouseUp = () => {
            document.removeEventListener("mousemove", onMouseMove);
            document.removeEventListener("mouseup", onMouseUp);
          };
          document.addEventListener("mousemove", onMouseMove);
          document.addEventListener("mouseup", onMouseUp);
        };

        const handleColResizeStart = (e, idx) => {
          if (isExport) return;
          e.preventDefault();
          e.stopPropagation();
          const startX = e.clientX;
          const currentWidths = data.colWidths || headers.map(() => 150);
          const startWidth = currentWidths[idx];

          const onMouseMove = (ev) => {
            const diff = ev.clientX - startX;
            const newW = Math.max(50, startWidth + diff);
            const newWidths = [...currentWidths];
            newWidths[idx] = newW;
            updateData({ colWidths: newWidths });
          };

          const onMouseUp = () => {
            document.removeEventListener("mousemove", onMouseMove);
            document.removeEventListener("mouseup", onMouseUp);
          };
          document.addEventListener("mousemove", onMouseMove);
          document.addEventListener("mouseup", onMouseUp);
        };

        // Default col widths if missing
        const colWidths = data.colWidths || headers.map(() => 150);

        return (
          <div className="my-3 inline-block max-w-full overflow-hidden border border-slate-300 rounded-lg shadow-sm bg-white">
            {/* Title Bar */}
            <div className="bg-slate-50 border-b border-slate-200 px-3 py-2 flex justify-between items-center w-full">
              <div className="flex-1 min-w-[100px]">
                {!isReadOnly && !isExport ? (
                  <input
                    type="text"
                    value={title}
                    onChange={(e) => updateData({ title: e.target.value })}
                    placeholder="Table Title..."
                    className="w-full bg-transparent font-bold text-sm text-slate-700 outline-none placeholder-slate-400"
                  />
                ) : (
                  title && (
                    <div className="font-bold text-sm text-slate-800">
                      {parseStyledText(title, searchQuery, isHighlighted)}
                    </div>
                  )
                )}
              </div>
              {/* Main Table Actions (Copy/Delete Table) */}
              {!isReadOnly && !isExport && (
                <div className="flex items-center gap-1 ml-2">
                  <button
                    onClick={onCopy}
                    className="p-1 hover:bg-slate-200 rounded text-slate-500"
                    title="Copy Table"
                  >
                    <CopyIcon />
                  </button>
                  <button
                    onClick={onDelete}
                    className="p-1 hover:bg-red-100 rounded text-red-500"
                    title="Delete Table"
                  >
                    <TrashIcon />
                  </button>
                </div>
              )}
            </div>

            <div className="overflow-x-auto custom-scrollbar">
              {/* REVERTED to w-auto to restore 'Beautiful Wrapping' */}
              <table className="w-auto text-sm text-left border-collapse table-fixed">
                <thead className="text-xs text-slate-700 bg-slate-100/50 border-b border-slate-300 relative group/header">
                  <tr
                    style={{
                      height: headerHeight ? `${headerHeight}px` : "auto",
                    }}
                  >
                    {headers.map((header, idx) => (
                      <th
                        key={idx}
                        className="border-r border-slate-200 last:border-r-0 relative group/th align-top p-0"
                        style={{ width: colWidths[idx] }}
                      >
                        {/* Header Content Container */}
                        <div className="w-full h-full relative group/headercell">
                          {!isReadOnly && !isExport ? (
                            <>
                              <AutoTextarea
                                value={header}
                                onChange={(e) =>
                                  handleHeaderChange(idx, e.target.value)
                                }
                                searchQuery={searchQuery}
                                isActiveMatch={isHighlighted}
                                // Padding-right 14 (3.5rem) to make space for the 2 buttons
                                className={`w-full bg-transparent outline-none font-bold text-slate-700 placeholder-slate-400 p-2 min-h-[32px] resize-none overflow-hidden pr-8 ${getAlignClass(
                                  headerAligns[idx]
                                )}`}
                                placeholder="Header"
                                style={{ height: "100%" }}
                              />

                              {/* DROPDOWN TRIGGER (More Options) - VISIBLE ON HOVER */}
                              <div
                                className={`absolute right-1 top-1 z-20 header-dropdown-container transition-opacity ${
                                  activeDropdown === idx
                                    ? "opacity-100"
                                    : "opacity-0 group-hover/headercell:opacity-100"
                                }`}
                              >
                                <button
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    setActiveDropdown(
                                      activeDropdown === idx ? null : idx
                                    );
                                  }}
                                  className={`p-1 rounded-md hover:bg-slate-200 text-slate-400 hover:text-slate-600 transition-colors ${
                                    activeDropdown === idx
                                      ? "bg-slate-200 text-slate-700"
                                      : "bg-white/80 backdrop-blur"
                                  }`}
                                  title="Column Options"
                                >
                                  <MoreOptionsIcon />
                                </button>

                                {/* COMPACT DROPDOWN MENU (Alignments + Delete) */}
                                {activeDropdown === idx && (
                                  <div
                                    className="absolute right-0 top-full mt-1 bg-white border border-slate-200 shadow-xl rounded-lg p-1.5 w-36 flex flex-col gap-1 cursor-default z-50 text-left"
                                    onMouseDown={(e) => e.stopPropagation()}
                                  >
                                    {/* Header Alignment */}
                                    <div className="flex items-center gap-1">
                                      <span className="text-[9px] font-bold text-slate-400 uppercase w-3">
                                        H
                                      </span>
                                      <div className="flex bg-slate-50 rounded p-0.5 border border-slate-100 flex-1">
                                        {["left", "center", "right"].map(
                                          (align) => (
                                            <button
                                              key={align}
                                              onClick={() =>
                                                setHeaderAlign(idx, align)
                                              }
                                              className={`flex-1 p-0.5 rounded flex justify-center transition-colors ${
                                                headerAligns[idx] === align
                                                  ? "bg-white shadow-sm text-blue-600 border border-slate-200"
                                                  : "text-slate-400 hover:text-slate-600 hover:bg-slate-100"
                                              }`}
                                            >
                                              {getAlignIcon(align)}
                                            </button>
                                          )
                                        )}
                                      </div>
                                    </div>

                                    {/* Column Alignment */}
                                    <div className="flex items-center gap-1">
                                      <span className="text-[9px] font-bold text-slate-400 uppercase w-3">
                                        C
                                      </span>
                                      <div className="flex bg-slate-50 rounded p-0.5 border border-slate-100 flex-1">
                                        {["left", "center", "right"].map(
                                          (align) => (
                                            <button
                                              key={align}
                                              onClick={() =>
                                                setColAlign(idx, align)
                                              }
                                              className={`flex-1 p-0.5 rounded flex justify-center transition-colors ${
                                                colAligns[idx] === align
                                                  ? "bg-white shadow-sm text-blue-600 border border-slate-200"
                                                  : "text-slate-400 hover:text-slate-600 hover:bg-slate-100"
                                              }`}
                                            >
                                              {getAlignIcon(align)}
                                            </button>
                                          )
                                        )}
                                      </div>
                                    </div>

                                    <div className="h-px bg-slate-100 my-0.5"></div>

                                    {/* Delete Button (Moved Inside & Compact) */}
                                    <button
                                      onClick={() => deleteColumn(idx)}
                                      className="flex items-center justify-center gap-1.5 p-1 text-[10px] text-red-500 hover:bg-red-50 rounded w-full font-bold transition-colors"
                                    >
                                      <TrashIcon /> Delete Col
                                    </button>
                                  </div>
                                )}
                              </div>
                            </>
                          ) : (
                            <div
                              className={`p-2 font-bold break-words whitespace-pre-wrap min-h-[32px] ${getAlignClass(
                                headerAligns[idx]
                              )}`}
                            >
                              {parseStyledText(
                                header,
                                searchQuery,
                                isHighlighted
                              )}
                            </div>
                          )}
                        </div>

                        {/* Col Resizer */}
                        {!isReadOnly && !isExport && (
                          <div
                            className="absolute right-0 top-0 bottom-0 w-1 cursor-col-resize hover:bg-blue-400 z-10"
                            onMouseDown={(e) => handleColResizeStart(e, idx)}
                          />
                        )}
                      </th>
                    ))}
                    {!isReadOnly && !isExport && (
                      <th
                        className="w-10 p-0 text-center bg-slate-100 border-l border-slate-300 align-middle hover:bg-blue-50 cursor-pointer"
                        onClick={addColumn}
                      >
                        <div className="w-full h-full flex items-center justify-center text-slate-400 hover:text-blue-600">
                          <PlusIcon />
                        </div>
                      </th>
                    )}
                  </tr>
                  {/* Header Height Resizer */}
                  {!isReadOnly && !isExport && (
                    <div
                      className="absolute bottom-0 left-0 right-0 h-1 cursor-row-resize hover:bg-blue-400 z-20 opacity-0 group-hover/header:opacity-100 transition-opacity"
                      onMouseDown={handleHeaderResizeStart}
                    />
                  )}
                </thead>
                <tbody>
                  {rows.map((row, rowIdx) => (
                    <tr
                      key={rowIdx}
                      className="bg-white border-b border-slate-200 last:border-b-0 hover:bg-slate-50/50 group/row"
                    >
                      {row.map((cell, colIdx) => (
                        <td
                          key={colIdx}
                          className="border-r border-slate-200 last:border-r-0 align-top p-0 relative"
                        >
                          {!isReadOnly && !isExport ? (
                            <AutoTextarea
                              value={cell}
                              onChange={(e) =>
                                handleCellChange(rowIdx, colIdx, e.target.value)
                              }
                              searchQuery={searchQuery}
                              isActiveMatch={isHighlighted}
                              className={`w-full bg-transparent outline-none text-slate-600 p-2 min-h-[36px] resize-none block ${getAlignClass(
                                colAligns[colIdx]
                              )}`}
                              placeholder="..."
                            />
                          ) : (
                            // FIXED: Added min-h-[36px] for reading mode rows
                            <div
                              className={`p-2 break-words whitespace-pre-wrap min-h-[36px] ${getAlignClass(
                                colAligns[colIdx]
                              )}`}
                            >
                              {parseStyledText(
                                cell,
                                searchQuery,
                                isHighlighted
                              )}
                            </div>
                          )}
                        </td>
                      ))}
                      {!isReadOnly && !isExport && (
                        <td className="w-10 bg-slate-50 text-center align-middle border-l border-slate-200">
                          <button
                            onClick={() => deleteRow(rowIdx)}
                            className="opacity-0 group-hover/row:opacity-100 p-1 text-slate-300 hover:text-red-500 transition-opacity"
                          >
                            <TrashIcon />
                          </button>
                        </td>
                      )}
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
            {!isReadOnly && !isExport && (
              <div
                onClick={addRow}
                className="w-full py-2 text-center bg-slate-50 hover:bg-blue-50 border-t border-slate-200 cursor-pointer text-slate-400 hover:text-blue-600 transition-colors flex justify-center items-center gap-2 text-xs font-medium"
              >
                <PlusIcon /> Add Row
              </div>
            )}
          </div>
        );
      };

      // --- SUB-COMPONENT: Note Content Manager (Updated for Line Tracking) ---
      const NoteContentManager = ({
        note,
        isExport,
        isReadingMode,
        searchQuery,
        onUpdate,
        isHighlighted,
        onCursorTrack, // Received from parent
      }) => {
        const effectiveBlocks = useMemo(() => {
          if (note.blocks && note.blocks.length > 0) return note.blocks;
          if (note.type === "table" && note.tableData) {
            return [
              {
                id: `legacy-tbl-${note.id}`,
                type: "table",
                data: note.tableData,
              },
            ];
          }
          return [
            {
              id: `legacy-txt-${note.id}`,
              type: "text",
              content: note.text || "",
            },
          ];
        }, [note]);

        const blocks = effectiveBlocks;

        const handleBlockUpdate = (blockId, updates) => {
          const newBlocks = blocks.map((b) =>
            b.id === blockId ? { ...b, ...updates } : b
          );
          const legacyText = newBlocks
            .map((b) => {
              if (b.type === "text") return b.content;
              if (b.type === "table" && b.data) {
                const headers = `| ${b.data.headers.join(" | ")} |`;
                const rows = b.data.rows
                  .map((row) => `| ${row.join(" | ")} |`)
                  .join("\n");
                return `${headers}\n${rows}`;
              }
              // Handle Divider in Legacy Text (Markdown standard)
              if (b.type === "divider") return "\n---\n";
              return "";
            })
            .join("\n\n");

          onUpdate(note.id, {
            blocks: newBlocks,
            text: legacyText,
            type: "note",
            tableData: null,
          });
        };

        const deleteBlock = (blockId) => {
          const newBlocks = blocks.filter((b) => b.id !== blockId);
          onUpdate(note.id, { blocks: newBlocks });
        };

        const copyTableToClipboard = (tableData) => {
          const tableString = JSON.stringify({
            _type: "SMART_MINDMAP_TABLE",
            data: tableData,
          });
          navigator.clipboard
            .writeText(tableString)
            .then(() => alert("Table copied, Ji! Paste it anywhere."))
            .catch((err) => console.error("Copy failed", err));
        };

        const handlePaste = (e, blockId) => {
          const pastedText = e.clipboardData.getData("text");
          try {
            const cleanText = pastedText.trim();
            const parsed = JSON.parse(cleanText);
            if (parsed && parsed._type === "SMART_MINDMAP_TABLE") {
              e.preventDefault();
              const newTableBlock = {
                id: `tbl-pasted-${Date.now()}`,
                type: "table",
                data: { ...parsed.data, title: parsed.data.title + " (Copy)" },
              };
              const index = blocks.findIndex((b) => b.id === blockId);
              const newBlocks = [...blocks];
              newBlocks.splice(index + 1, 0, newTableBlock);
              newBlocks.splice(index + 2, 0, {
                id: `txt-space-${Date.now()}`,
                type: "text",
                content: "",
              });
              const legacyText = newBlocks
                .map((b) => {
                  if (b.type === "text") return b.content;
                  if (b.type === "table") return "[Table]";
                  if (b.type === "divider") return "---";
                  return "";
                })
                .join("\n");
              onUpdate(note.id, {
                blocks: newBlocks,
                text: legacyText,
                type: "note",
                tableData: null,
              });
            }
          } catch (err) {}
        };

        // handleKeyDown (Bold, Tab, Enter logic remains same)
        const handleKeyDown = (e, blockId, currentText) => {
          const textarea = e.target;
          if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "b") {
            e.preventDefault();
            const start = textarea.selectionStart;
            const end = textarea.selectionEnd;
            const selection = currentText.substring(start, end);
            const newCursorPos = end + 4;
            let newContent = !selection
              ? `${currentText.substring(0, start)}****${currentText.substring(
                  end
                )}`
              : `${currentText.substring(
                  0,
                  start
                )}**${selection}**${currentText.substring(end)}`;
            handleBlockUpdate(blockId, { content: newContent });
            setTimeout(() => {
              textarea.selectionStart = textarea.selectionEnd = selection
                ? newCursorPos
                : start + 2;
            }, 0);
          }
          if (e.key === "Tab") {
            e.preventDefault();
            const start = textarea.selectionStart;
            const end = textarea.selectionEnd;
            const currentLineStart =
              currentText.lastIndexOf("\n", start - 1) + 1;
            const currentLineEnd = currentText.indexOf("\n", start);
            const lineEndIndex =
              currentLineEnd === -1 ? currentText.length : currentLineEnd;
            const currentLine = currentText.substring(
              currentLineStart,
              lineEndIndex
            );
            if (/^\s*(\*|-)\s/.test(currentLine)) {
              const newText =
                currentText.substring(0, currentLineStart) +
                "  " +
                currentText.substring(currentLineStart);
              handleBlockUpdate(blockId, { content: newText });
              setTimeout(() => {
                textarea.selectionStart = start + 2;
                textarea.selectionEnd = end + 2;
              }, 0);
            } else {
              const newText =
                currentText.substring(0, start) +
                "    " +
                currentText.substring(end);
              handleBlockUpdate(blockId, { content: newText });
              setTimeout(() => {
                textarea.selectionStart = textarea.selectionEnd = start + 4;
              }, 0);
            }
          }
          if (e.key === "Enter" && !e.shiftKey) {
            const start = textarea.selectionStart;
            const beforeCursor = currentText.substring(0, start);
            const currentLine = beforeCursor.split("\n").pop();
            const bulletMatch = currentLine.match(/^(\s*)(\*|-)\s/);
            if (bulletMatch) {
              e.preventDefault();
              handleBlockUpdate(blockId, {
                content: `${beforeCursor}\n${
                  bulletMatch[0]
                }${currentText.substring(start)}`,
              });
              setTimeout(() => {
                textarea.selectionStart = textarea.selectionEnd =
                  start + 1 + bulletMatch[0].length;
              }, 0);
            }
          }
        };

        const handleTextChange = (blockId, newText) => {
          // 1. TABLE SHORTCUT (\t)
          if (newText.includes("\\t")) {
            const splitParts = newText.split("\\t");
            const newTableBlock = {
              id: `tbl-${Date.now()}`,
              type: "table",
              data: {
                title: "",
                headers: ["Col 1", "Col 2"],
                rows: [
                  ["", ""],
                  ["", ""],
                ],
                colWidths: [150, 150],
                rowHeights: [40, 40],
                headerAligns: ["left", "left"],
                colAligns: ["left", "left"],
              },
            };
            const currentIdx = blocks.findIndex((b) => b.id === blockId);
            const updatedBlocks = [...blocks];
            updatedBlocks[currentIdx] = {
              ...updatedBlocks[currentIdx],
              content: splitParts[0],
            };
            updatedBlocks.splice(currentIdx + 1, 0, newTableBlock, {
              id: `txt-${Date.now()}`,
              type: "text",
              content: splitParts.slice(1).join(""),
            });
            onUpdate(note.id, {
              blocks: updatedBlocks,
              text: updatedBlocks
                .map((b) => {
                  if (b.type === "text") return b.content;
                  if (b.type === "table") return "[Table]";
                  if (b.type === "divider") return "---";
                  return "";
                })
                .join("\n"),
            });
          }
          // 2. DIVIDER SHORTCUT (\h) - NEW FEATURE
          else if (newText.includes("\\h")) {
            const splitParts = newText.split("\\h");

            // Create Divider Block
            const newDividerBlock = {
              id: `div-${Date.now()}`,
              type: "divider",
            };

            // Create New Text Block (for text after \h)
            const newTextBlock = {
              id: `txt-${Date.now() + 1}`,
              type: "text",
              content: splitParts.slice(1).join(""),
            };

            const currentIdx = blocks.findIndex((b) => b.id === blockId);
            const updatedBlocks = [...blocks];

            // Update current block content (before \h)
            updatedBlocks[currentIdx] = {
              ...updatedBlocks[currentIdx],
              content: splitParts[0],
            };

            // Insert Divider and New Text Block
            updatedBlocks.splice(
              currentIdx + 1,
              0,
              newDividerBlock,
              newTextBlock
            );

            onUpdate(note.id, {
              blocks: updatedBlocks,
              text: updatedBlocks
                .map((b) => {
                  if (b.type === "text") return b.content;
                  if (b.type === "table") return "[Table]";
                  if (b.type === "divider") return "---";
                  return "";
                })
                .join("\n"),
            });

            // Focus the new text block automatically
            setTimeout(() => {
              const el = document.getElementById(
                `block-input-${newTextBlock.id}`
              );
              if (el) el.focus();
            }, 50);
          } else {
            handleBlockUpdate(blockId, { content: newText });
          }
        };

        return (
          <div className="flex flex-col gap-1 w-full">
            {blocks.map((block) => {
              // --- RENDER DIVIDER ---
              if (block.type === "divider") {
                return (
                  <div
                    key={block.id}
                    className="relative group/block my-2 py-1 select-none"
                  >
                    <hr className="border-t-2 border-slate-200 w-full" />
                    {!isReadingMode && !isExport && (
                      <button
                        onClick={() => deleteBlock(block.id)}
                        className="absolute right-0 top-1/2 -translate-y-1/2 opacity-0 group-hover/block:opacity-100 bg-white shadow-sm border border-slate-200 text-slate-400 hover:text-red-500 p-1 rounded-full transition-all transform hover:scale-110"
                        title="Remove Line"
                      >
                        <TrashIcon />
                      </button>
                    )}
                  </div>
                );
              }

              // --- RENDER TABLE ---
              if (block.type === "table") {
                return (
                  <div key={block.id} className="relative group/block my-1">
                    <TableEditor
                      data={block.data}
                      isReadOnly={isReadingMode}
                      isExport={isExport}
                      searchQuery={searchQuery}
                      onUpdate={(newData) =>
                        handleBlockUpdate(block.id, { data: newData })
                      }
                      onCopy={() => copyTableToClipboard(block.data)}
                      onDelete={() => deleteBlock(block.id)}
                    />
                  </div>
                );
              }

              // --- RENDER TEXT ---
              return (
                <div key={block.id} className="w-full relative group/textblock">
                  {!isExport && !isReadingMode ? (
                    <div className="relative min-h-[1.6em]">
                      <AutoTextarea
                        id={`block-input-${block.id}`}
                        value={block.content}
                        onChange={(e) =>
                          handleTextChange(block.id, e.target.value)
                        }
                        onKeyDown={(e) =>
                          handleKeyDown(e, block.id, block.content)
                        }
                        onPaste={(e) => handlePaste(e, block.id)}
                        // NEW: Calculate LINE NUMBER (Pseudo-ID) and pass it up
                        onCursorTrack={(pos) => {
                          if (onCursorTrack) {
                            const val = block.content || "";
                            // Count newlines before cursor to get 0-based line index
                            const lineNum =
                              val.substr(0, pos).split("\n").length - 1;
                            onCursorTrack(note.id, block.id, pos, lineNum);
                          }
                        }}
                        searchQuery={searchQuery}
                        isActiveMatch={isHighlighted}
                        className="w-full bg-transparent border-none focus:outline-none resize-none font-sans text-sm p-0 m-0"
                        style={{
                          color: "inherit",
                          lineHeight: "1.6",
                          minHeight: "1.6em",
                        }}
                        placeholder="Type text... (\t for table, \h for line)"
                      />
                      {blocks.length > 1 && !block.content && (
                        <button
                          onClick={() => deleteBlock(block.id)}
                          className="absolute -left-5 top-0 opacity-0 group-hover/textblock:opacity-100 text-slate-300 hover:text-red-400 p-0.5"
                        >
                          <TrashIcon />
                        </button>
                      )}
                    </div>
                  ) : (
                    <div
                      className="w-full whitespace-pre-wrap text-sm"
                      style={{ fontFamily: "sans-serif", lineHeight: "1.6" }}
                    >
                      {parseMarkdown(
                        block.content,
                        searchQuery,
                        isHighlighted,
                        isExport
                      )}
                    </div>
                  )}
                </div>
              );
            })}
          </div>
        );
      };

      // --- UPDATED: NOTES RENDERER (Passes Highlight State & Cursor Tracker) ---
      const NotesListRenderer = ({
        notesData,
        isExport = false,
        isReadingMode = false,
        onUpdateNote,
        onDeleteNote,
        onMoveUp,
        onMoveDown,
        highlightedId,
        searchQuery,
        onCursorTrack, // <--- NEW PROP
      }) => {
        const handleHeadingChange = (id, newHeading) => {
          onUpdateNote(id, { heading: newHeading });
        };

        return (
          <div className="space-y-4">
            {notesData.map((note, index) => {
              const isFilled = note.style === "filled";
              const noteColor = note.color || COLORS[index % COLORS.length];
              const textColor = isFilled ? "white" : "#334155";
              const isHighlighted = highlightedId === note.id;
              const isCollapsed = note.isCollapsed && !isExport;
              const currentBorderColor = isHighlighted ? "#fb923c" : noteColor;
              const showToolbar = !isExport;
              const displayHeading = note.heading || `Note ${index + 1}`;

              return (
                <div
                  key={note.id}
                  id={`note-${note.id}`}
                  className={`relative group transition-all duration-300 rounded-lg ${
                    isHighlighted
                      ? "ring-4 ring-orange-400 ring-offset-4 shadow-xl scale-[1.01] z-10"
                      : "hover:shadow-md"
                  } mt-4`}
                >
                  {/* ... Toolbar Logic (Unchanged) ... */}
                  {showToolbar && (
                    <div className="absolute right-2 top-2 flex flex-row items-center gap-2 opacity-0 group-hover:opacity-100 transition-opacity z-20 bg-white/95 backdrop-blur px-2 py-1 rounded-full shadow-sm border border-slate-200">
                      <div className="flex items-center gap-1 border-r border-slate-200 pr-2">
                        <button
                          onClick={() => onMoveUp(index)}
                          className="p-1 hover:bg-slate-200 rounded text-slate-500 hover:text-blue-600"
                        >
                          <ArrowUpIcon />
                        </button>
                        <button
                          onClick={() => onMoveDown(index)}
                          className="p-1 hover:bg-slate-200 rounded text-slate-500 hover:text-blue-600"
                        >
                          <ArrowDownIcon />
                        </button>
                      </div>
                      <input
                        type="color"
                        value={note.color || noteColor}
                        onChange={(e) =>
                          onUpdateNote(note.id, { color: e.target.value })
                        }
                        className="w-5 h-5 rounded cursor-pointer border-none bg-transparent p-0"
                      />
                      <button
                        onClick={() =>
                          onUpdateNote(note.id, {
                            style: isFilled ? "outline" : "filled",
                          })
                        }
                        className="p-1 hover:bg-slate-100 rounded text-slate-500 hover:text-blue-600"
                      >
                        {isFilled ? (
                          <SquareIcon className="w-5 h-5" />
                        ) : (
                          <FilledSquareIcon className="w-5 h-5" />
                        )}
                      </button>
                      <div className="w-px h-4 bg-slate-200 mx-1"></div>
                      <button
                        onClick={() => !isReadingMode && onDeleteNote(note.id)}
                        disabled={isReadingMode}
                        className={`p-1 rounded transition-colors ${
                          isReadingMode
                            ? "text-slate-300 cursor-not-allowed"
                            : "text-red-400 hover:text-red-600"
                        }`}
                      >
                        <TrashIcon />
                      </button>
                    </div>
                  )}

                  <div
                    className={`rounded-lg p-4 transition-all shadow-sm ${
                      isFilled ? "" : "bg-white"
                    }`}
                    style={{
                      backgroundColor: isFilled ? noteColor : "white",
                      borderLeft: isFilled ? "none" : `6px solid ${noteColor}`,
                      borderTop: isFilled
                        ? "none"
                        : `1px solid ${currentBorderColor}`,
                      borderRight: isFilled
                        ? "none"
                        : `1px solid ${currentBorderColor}`,
                      borderBottom: isFilled
                        ? "none"
                        : `1px solid ${currentBorderColor}`,
                      color: textColor,
                    }}
                  >
                    {/* ... Heading Logic (Unchanged) ... */}
                    <div
                      className="flex items-center gap-2 mb-3 pr-24 border-b border-black/5 pb-2"
                      style={{
                        borderColor: isFilled
                          ? "rgba(255,255,255,0.2)"
                          : "rgba(0,0,0,0.05)",
                      }}
                    >
                      {!isExport && (
                        <button
                          onClick={() =>
                            onUpdateNote(note.id, {
                              isCollapsed: !note.isCollapsed,
                            })
                          }
                          className="p-1 hover:bg-black/5 rounded transition-colors flex-shrink-0"
                        >
                          {note.isCollapsed ? (
                            <ChevronRightSmall />
                          ) : (
                            <ChevronDownSmall />
                          )}
                        </button>
                      )}
                      {!isExport && !isReadingMode ? (
                        <input
                          type="text"
                          value={note.heading || ""}
                          onChange={(e) =>
                            handleHeadingChange(note.id, e.target.value)
                          }
                          placeholder="Note Heading..."
                          className={`bg-transparent border-none focus:outline-none font-bold text-sm w-full placeholder-opacity-50 ${
                            isFilled
                              ? "placeholder-white"
                              : "placeholder-slate-400"
                          }`}
                          style={{ color: "inherit" }}
                        />
                      ) : (
                        <div className="font-bold text-sm select-text w-full">
                          {parseMarkdown(
                            displayHeading,
                            searchQuery,
                            isHighlighted,
                            false
                          )}
                        </div>
                      )}
                      {isHighlighted && (
                        <span className="bg-orange-500 text-white text-[10px] px-1.5 py-0.5 rounded-full font-bold uppercase tracking-wide shadow-sm animate-pulse flex-shrink-0 ml-auto">
                          Target
                        </span>
                      )}
                    </div>

                    {isCollapsed ? (
                      <div
                        className="truncate overflow-hidden text-xs opacity-70 cursor-pointer pl-6 select-none italic"
                        onClick={() =>
                          !isExport &&
                          onUpdateNote(note.id, { isCollapsed: false })
                        }
                      >
                        (Click to expand content...)
                      </div>
                    ) : (
                      // Pass props down
                      <NoteContentManager
                        note={note}
                        isExport={isExport}
                        isReadingMode={isReadingMode}
                        searchQuery={searchQuery}
                        onUpdate={onUpdateNote}
                        isHighlighted={isHighlighted}
                        onCursorTrack={onCursorTrack} // <--- Pass here
                      />
                    )}
                  </div>
                </div>
              );
            })}
            {notesData.length === 0 && (
              <div className="text-center text-slate-400 py-20 border-2 border-dashed border-slate-200 rounded-xl">
                No notes yet. Click "Add Point" to start.
              </div>
            )}
          </div>
        );
      };

      // --- GLOBAL STATE: Persist Scroll Position across Tab Switches ---
      let globalNotesScrollPos = 0;
      let globalNotesScrollRatio = 0; // <--- NEW: Track Ratio for smooth toggling
      let globalNotesCursor = null;

      // --- NOTES PAGE COMPONENT (Seamless Scroll Sync) ---
      const NotesView = ({
        notesData,
        onAddNote,
        onUpdateNote,
        onDeleteNote,
        onDownloadNotes,
        isDownloading,
        onMoveUp,
        onMoveDown,
        isReadingMode,
        setIsReadingMode,
        searchState,
        setSearchState,
        handleSearchNext,
        handleSearchPrev,
        handleReplace,
        handleReplaceAll,
        showSearch,
        setShowSearch,
        onCloseSearch,
      }) => {
        const scrollContainerRef = useRef(null);

        // 1. Capture Scroll RATIO BEFORE switching modes
        const handleToggleReadingMode = () => {
          if (scrollContainerRef.current) {
            const container = scrollContainerRef.current;
            const maxScroll = container.scrollHeight - container.clientHeight;

            // Save Ratio (Percentage) instead of Pixels for Mode Switching
            if (maxScroll > 0) {
              globalNotesScrollRatio = container.scrollTop / maxScroll;
            } else {
              globalNotesScrollRatio = 0;
            }
            // Also save pixels for tab switching
            globalNotesScrollPos = container.scrollTop;
          }
          setIsReadingMode(!isReadingMode);
        };

        // 2. Restore Scroll Position using RATIO
        useLayoutEffect(() => {
          if (scrollContainerRef.current) {
            const container = scrollContainerRef.current;
            const maxScroll = container.scrollHeight - container.clientHeight;

            // If we have a ratio saved, use it to calculate new pixel position
            if (maxScroll > 0) {
              container.scrollTop = globalNotesScrollRatio * maxScroll;
            } else {
              container.scrollTop = globalNotesScrollPos;
            }
          }
        }, [isReadingMode]);

        // 3. Keep Global Scroll Updated
        const handleScroll = () => {
          if (scrollContainerRef.current) {
            const container = scrollContainerRef.current;
            globalNotesScrollPos = container.scrollTop;

            // Keep ratio updated too, so tab switching keeps relative position if needed
            const maxScroll = container.scrollHeight - container.clientHeight;
            if (maxScroll > 0) {
              globalNotesScrollRatio = container.scrollTop / maxScroll;
            }
          }
        };

        // 4. Cursor Tracking (Existing Logic preserved)
        const handleRecordCursor = (noteId, blockId, pos, visualOffset = 0) => {
          globalNotesCursor = { noteId, blockId, pos, visualOffset };
        };

        // 5. Restore Focus/Cursor on Edit Mode (Existing Logic)
        useEffect(() => {
          if (!isReadingMode && globalNotesCursor) {
            const { blockId, pos, visualOffset } = globalNotesCursor;
            setTimeout(() => {
              const el = document.getElementById(`block-input-${blockId}`);
              const container = scrollContainerRef.current;
              if (el && container) {
                el.focus({ preventScroll: true });
                el.setSelectionRange(pos, pos);
                // No forced scroll here, relying on LayoutEffect ratio sync
              }
            }, 50);
          }
        }, [isReadingMode]);

        // 6. Shortcut (Ctrl+Shift+E)
        useEffect(() => {
          const handleShortcut = (e) => {
            if (
              (e.ctrlKey || e.metaKey) &&
              e.shiftKey &&
              e.key.toLowerCase() === "e"
            ) {
              e.preventDefault();
              handleToggleReadingMode();
            }
          };
          window.addEventListener("keydown", handleShortcut);
          return () => window.removeEventListener("keydown", handleShortcut);
        }, [isReadingMode]);

        return (
          <div className="flex-1 bg-slate-50 flex flex-col h-full overflow-hidden">
            {/* Header */}
            <div className="flex-none bg-slate-50 border-b border-slate-200 px-8 py-4 z-10 shadow-sm transition-all">
              <div className="max-w-5xl mx-auto flex flex-col gap-4">
                <div className="flex justify-between items-center">
                  <h2 className="text-3xl font-bold text-slate-800">
                    My Notes
                  </h2>
                  <div className="flex gap-2">
                    <button
                      onClick={handleToggleReadingMode}
                      className={`flex items-center gap-2 px-3 py-2 ${
                        isReadingMode
                          ? "bg-purple-100 text-purple-700 ring-2 ring-purple-400"
                          : "bg-white text-slate-600"
                      } border border-slate-200 hover:bg-slate-50 rounded-lg shadow-sm transition-all text-sm font-medium`}
                      title="Toggle Reading Mode (Ctrl + Shift + E)"
                    >
                      <EyeIcon /> {isReadingMode ? "Reading Mode" : "Edit Mode"}
                    </button>

                    <button
                      onClick={() =>
                        showSearch ? onCloseSearch() : setShowSearch(true)
                      }
                      className={`flex items-center gap-2 px-3 py-2 ${
                        showSearch
                          ? "bg-blue-100 text-blue-700"
                          : "bg-white text-slate-600"
                      } border border-slate-200 hover:bg-slate-50 rounded-lg shadow-sm transition-all text-sm font-medium`}
                    >
                      <SearchIcon /> {showSearch ? "Hide Search" : "Find"}
                    </button>

                    <button
                      onClick={onAddNote}
                      className="flex items-center gap-2 px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-full shadow-md transition-all text-sm font-medium"
                    >
                      <PlusIcon /> Add Point
                    </button>

                    {/* Export Buttons */}
                    <div className="flex items-center bg-white rounded-full p-1 border border-slate-200 shadow-sm ring-1 ring-slate-100">
                      <div className="flex items-center gap-2 pl-3 pr-2 text-slate-400 border-r border-slate-100">
                        {isDownloading ? (
                          <svg
                            className="animate-spin h-4 w-4"
                            viewBox="0 0 24 24"
                          >
                            <circle
                              className="opacity-25"
                              cx="12"
                              cy="12"
                              r="10"
                              stroke="currentColor"
                              strokeWidth="4"
                              fill="none"
                            ></circle>
                            <path
                              className="opacity-75"
                              fill="currentColor"
                              d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                            ></path>
                          </svg>
                        ) : (
                          <svg
                            xmlns="http://www.w3.org/2000/svg"
                            width="18"
                            height="18"
                            viewBox="0 0 24 24"
                            fill="none"
                            stroke="currentColor"
                            strokeWidth="2.5"
                            strokeLinecap="round"
                            strokeLinejoin="round"
                          >
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
                            <polyline points="7 10 12 15 17 10" />
                            <line x1="12" x2="12" y1="15" y2="3" />
                          </svg>
                        )}
                        <span className="text-[10px] font-black uppercase tracking-widest text-slate-400 mr-1">
                          Export
                        </span>
                      </div>
                      <button
                        onClick={() => onDownloadNotes("png")}
                        disabled={isDownloading}
                        className="px-4 py-2 text-xs font-black text-slate-500 hover:text-blue-600 hover:bg-slate-50 transition-all flex items-center justify-center"
                      >
                        PNG
                      </button>
                      <div className="w-px h-4 bg-slate-100"></div>
                      <button
                        onClick={() => onDownloadNotes("svg")}
                        disabled={isDownloading}
                        className="px-4 py-2 text-xs font-black text-blue-600 hover:text-blue-700 hover:bg-slate-50 rounded-r-full transition-all flex items-center justify-center"
                      >
                        SVG
                      </button>
                    </div>
                  </div>
                </div>

                {/* Search Bar */}
                {showSearch && (
                  <div className="flex flex-wrap items-center gap-2 bg-white p-2 rounded-lg border border-blue-200 shadow-sm animate-fade-in">
                    <div className="flex items-center bg-slate-100 rounded px-2 py-1 flex-1">
                      <SearchIcon />
                      <input
                        type="text"
                        placeholder="Find..."
                        value={searchState.query}
                        onChange={(e) =>
                          setSearchState((prev) => ({
                            ...prev,
                            query: e.target.value,
                          }))
                        }
                        className="bg-transparent border-none focus:outline-none text-sm ml-2 w-full py-1"
                        autoFocus
                      />
                      <span className="text-xs text-slate-400 font-mono whitespace-nowrap px-1">
                        {searchState.matches.length > 0
                          ? `${
                              searchState.matches.length > 0
                                ? searchState.currentIndex + 1
                                : 0
                            }/${searchState.matches.length}`
                          : "0/0"}
                      </span>
                    </div>
                    <div className="flex items-center bg-slate-100 rounded px-2 py-1 flex-1">
                      <span className="text-slate-400 text-xs mr-2 font-bold">
                        REPLACE
                      </span>
                      <input
                        type="text"
                        placeholder="Replace with..."
                        value={searchState.replaceText}
                        onChange={(e) =>
                          setSearchState((prev) => ({
                            ...prev,
                            replaceText: e.target.value,
                          }))
                        }
                        className="bg-transparent border-none focus:outline-none text-sm w-full py-1"
                      />
                    </div>
                    <div className="flex items-center gap-1">
                      <button
                        onClick={handleSearchPrev}
                        className="p-1.5 hover:bg-blue-50 text-slate-600 rounded"
                      >
                        <ChevronLeftIcon />
                      </button>
                      <button
                        onClick={handleSearchNext}
                        className="p-1.5 hover:bg-blue-50 text-slate-600 rounded"
                      >
                        <ChevronRightIcon />
                      </button>
                    </div>
                    <div className="w-px h-6 bg-slate-200 mx-1"></div>
                    <button
                      onClick={handleReplace}
                      className="px-3 py-1.5 bg-blue-50 text-blue-700 hover:bg-blue-100 rounded text-xs font-bold transition-colors"
                    >
                      Replace
                    </button>
                    <button
                      onClick={handleReplaceAll}
                      className="px-3 py-1.5 bg-slate-100 text-slate-700 hover:bg-slate-200 rounded text-xs font-bold transition-colors"
                    >
                      All
                    </button>
                    <button
                      onClick={onCloseSearch}
                      className="ml-1 p-1.5 hover:bg-red-50 text-slate-400 hover:text-red-500 rounded"
                    >
                      <CloseIcon />
                    </button>
                  </div>
                )}
              </div>
            </div>

            {/* Scrollable Container */}
            <div
              ref={scrollContainerRef}
              onScroll={handleScroll}
              className="flex-1 overflow-y-auto p-8 pt-4 custom-scrollbar"
            >
              <div className="max-w-5xl mx-auto space-y-6 pb-20">
                <div id="notes-container">
                  <NotesListRenderer
                    notesData={notesData}
                    isReadingMode={isReadingMode}
                    onUpdateNote={onUpdateNote}
                    onDeleteNote={onDeleteNote}
                    onMoveUp={onMoveUp}
                    onMoveDown={onMoveDown}
                    highlightedId={
                      searchState.matches[searchState.currentIndex]
                    }
                    searchQuery={searchState.query}
                    isExport={false}
                    onCursorTrack={handleRecordCursor} // Cursor tracking passed down
                  />
                </div>
              </div>
            </div>
          </div>
        );
      };

      // --- MAIN COMPONENT ---
      function App() {
        const [viewMode, setViewMode] = useState("map");

        // --- NEW STATE: File Handle (To remember where file is saved) ---
        const [currentFileHandle, setCurrentFileHandle] = useState(null);

        // SHOW ALL SHORTCUTS
        const [showShortcuts, setShowShortcuts] = useState(false);

        // --- NEW STATES FOR DIRTY TRACKING (Moved Inside App) ---
        const [isDirty, setIsDirty] = useState(false);
        const [dirtyLevel1Nodes, setDirtyLevel1Nodes] = useState(new Set());

        // --- TOAST STATE ---
        const [toast, setToast] = useState({ show: false, message: "" });

        const showToast = (msg) => {
          setToast({ show: true, message: msg });
        };

        // Helper: Find the Level 1 Ancestor
        const findLevel1Ancestor = useCallback((nodeId, currentNodes) => {
          let node = currentNodes.find((n) => n.id === nodeId);
          if (!node || node.id === "root") return null;
          if (node.parentId === "root") return node.id;
          return findLevel1Ancestor(node.parentId, currentNodes);
        }, []);

        // Helper: Function to trigger dirty state
        // Note: We need to access 'nodes' here, so it's defined inside App
        const markDirty = useCallback(
          (nodeId = null) => {
            setIsDirty(true);
            if (nodeId && nodeId !== "root") {
              // We use a functional update or ensure nodes is in deps
              setNodes((prevNodes) => {
                const l1Id = findLevel1Ancestor(nodeId, prevNodes);
                if (l1Id) {
                  setDirtyLevel1Nodes((prev) => new Set(prev).add(l1Id));
                } else {
                  const node = prevNodes.find((n) => n.id === nodeId);
                  if (node && node.parentId === "root") {
                    setDirtyLevel1Nodes((prev) => new Set(prev).add(nodeId));
                  }
                }
                return prevNodes;
              });
            }
          },
          [findLevel1Ancestor]
        );

        // --- BROWSER CLOSE/REFRESH ALERT ---
        useEffect(() => {
          const handleBeforeUnload = (e) => {
            if (isDirty) {
              const message =
                "Ji, you have unsaved changes! Are you sure you want to leave?";
              e.preventDefault();
              e.returnValue = message;
              return message;
            }
          };
          window.addEventListener("beforeunload", handleBeforeUnload);
          return () =>
            window.removeEventListener("beforeunload", handleBeforeUnload);
        }, [isDirty]);

        // Default STATE: Edit Mode
        const [isReadingMode, setIsReadingMode] = useState(false);

        // STATE: MIND MAP
        const [nodes, setNodes] = useState([
          {
            id: "root",
            text: "Central Idea",
            x: 0,
            y: 0,
            width: 140,
            height: 50,
            depth: 0,
            color: COLORS[0],
            parentId: null,
            isCollapsed: false,
          },
        ]);

        // --- NEW EFFECT: Sync Document Title with Root Node (Project Name) ---
        useEffect(() => {
          const rootNode = nodes.find((n) => n.id === "root");
          if (rootNode) {
            // Update browser tab title to match Root Node text
            // If text is empty, fallback to "MindMapper Pro"
            document.title =
              rootNode.text && rootNode.text.trim() !== ""
                ? rootNode.text
                : "MindMapper Pro";
          }
        }, [nodes]);

        // STATE: NOTES
        const [notesData, setNotesData] = useState([]);
        const [isExportingNotes, setIsExportingNotes] = useState(false);

        // STATE: SELECTION & CANVAS
        const [selectedNodeId, setSelectedNodeId] = useState(null);
        const [isProcessing, setIsProcessing] = useState(false);
        const [scale, setScale] = useState(1);
        const [pan, setPan] = useState({
          x: window.innerWidth / 2 - 70,
          y: window.innerHeight / 2 - 25,
        });
        const [isDraggingCanvas, setIsDraggingCanvas] = useState(false);
        const [isDraggingRoot, setIsDraggingRoot] = useState(false);
        const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
        const [isDownloading, setIsDownloading] = useState(false);
        const [nodeColor, setNodeColor] = useState(DEFAULT_COLOR);

        // STATE: STYLE DIALOG
        const [styleDialogOpen, setStyleDialogOpen] = useState(false);
        const [pendingStyleType, setPendingStyleType] = useState(null);

        // STATE: MOVE MODE
        const [isMoveMode, setIsMoveMode] = useState(false);
        const [movingNodeId, setMovingNodeId] = useState(null);

        const [exportConfig, setExportConfig] = useState(null);
        const fileInputRef = useRef(null);
        const projectInputRef = useRef(null);
        const canvasRef = useRef(null);
        const scaleRef = useRef(scale);
        const panRef = useRef(pan);

        // --- HELPER: Pan Camera to Node (Fixed) ---
        const panToNode = useCallback(
          (nodeId) => {
            // We need to find the node in the current visible set
            const node = visibleNodes.find((n) => n.id === nodeId);

            if (node) {
              // Calculate center
              const screenCx = (window.innerWidth - 80) / 2;
              const screenCy = (window.innerHeight + 64) / 2;

              // Update Pan
              const newPanX = screenCx - (node.x + node.width / 2) * scale;
              const newPanY = screenCy - (node.y + node.height / 2) * scale;

              setPan({ x: newPanX, y: newPanY });
            }
          },
          [visibleNodes, scale]
        );

        // --- 1. NEW STATE: HISTORY ---
        const [history, setHistory] = useState({ past: [], future: [] });
        const [notesHistory, setNotesHistory] = useState({
          past: [],
          future: [],
        });

        // --- 2. HELPER: WRAPPER TO SAVE HISTORY ---
        // Use this function instead of setNodes() whenever you make a change you want to Undo later
        const updateNodesWithHistory = (newNodes) => {
          setHistory((prev) => ({
            past: [...prev.past, nodes], // Push current state to past
            future: [], // Clear future (branching off)
          }));
          setNodes(newNodes);
        };

        const updateNotesWithHistory = (newNotes) => {
          setNotesHistory((prev) => ({
            past: [...prev.past, notesData], // Push current state to past
            future: [], // Clear future because we made a new change
          }));
          setNotesData(newNotes);
          setIsDirty(true);
        };

        // --- 3. ACTIONS: UNDO & REDO ---
        const handleUndo = useCallback(() => {
          setHistory((prev) => {
            if (prev.past.length === 0) return prev; // Nothing to undo

            const previous = prev.past[prev.past.length - 1];
            const newPast = prev.past.slice(0, -1);

            setNodes(previous); // Restore old state
            return {
              past: newPast,
              future: [nodes, ...prev.future], // Push current to future
            };
          });
        }, [nodes]); // Depend on current 'nodes'

        const handleRedo = useCallback(() => {
          setHistory((prev) => {
            if (prev.future.length === 0) return prev; // Nothing to redo

            const next = prev.future[0];
            const newFuture = prev.future.slice(1);

            setNodes(next); // Restore next state
            return {
              past: [...prev.past, nodes], // Push current to past
              future: newFuture,
            };
          });
        }, [nodes]);

        const handleUndoNotes = useCallback(() => {
          setNotesHistory((prev) => {
            if (prev.past.length === 0) return prev; // Nothing to undo

            const previous = prev.past[prev.past.length - 1];
            const newPast = prev.past.slice(0, -1);

            setNotesData(previous); // Restore old state
            return {
              past: newPast,
              future: [notesData, ...prev.future], // Push current to future
            };
          });
        }, [notesData]);

        const handleRedoNotes = useCallback(() => {
          setNotesHistory((prev) => {
            if (prev.future.length === 0) return prev; // Nothing to redo

            const next = prev.future[0];
            const newFuture = prev.future.slice(1);

            setNotesData(next); // Restore next state
            return {
              past: [...prev.past, notesData], // Push current to past
              future: newFuture,
            };
          });
        }, [notesData]);

        // --- 4. SHORTCUTS: UNDO, REDO & AUTO-FOCUS NAVIGATION (FIXED) ---
        useEffect(() => {
          const handleKeyDown = (e) => {
            // 1. Undo (Ctrl+Z)
            if (
              (e.ctrlKey || e.metaKey) &&
              e.key.toLowerCase() === "z" &&
              !e.shiftKey
            ) {
              e.preventDefault();
              // Check which mode we are in
              if (viewMode === "map") {
                handleUndo();
              } else {
                handleUndoNotes();
              }
              return;
            }
            // 2. Redo (Ctrl+Y or Ctrl+Shift+Z)
            if (
              ((e.ctrlKey || e.metaKey) &&
                e.key.toLowerCase() === "z" &&
                e.shiftKey) ||
              ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "y")
            ) {
              e.preventDefault();
              if (viewMode === "map") {
                handleRedo();
              } else {
                handleRedoNotes();
              }
              return;
            }

            // 3. Map Navigation Logic (Only if in Map Mode & Node Selected)
            if (viewMode == "map" && selectedNodeId) {
              const currentNode = visibleNodes.find(
                (n) => n.id === selectedNodeId
              );
              if (!currentNode) return;

              // HELPER: Move Selection, Pan Camera, and FOCUS Text
              const performMove = (nextNodeId) => {
                // e.preventDefault() is handled in individual checks
                setSelectedNodeId(nextNodeId);

                // Use timeout to allow React to render the new selection state
                setTimeout(() => {
                  // A. Pan Camera (Recalculate layout to ensure accuracy)
                  const allNodes = calculateLayout(nodes);
                  const target = allNodes.find((n) => n.id === nextNodeId);
                  if (target) {
                    const screenCx = (window.innerWidth - 80) / 2;
                    const screenCy = (window.innerHeight + 64) / 2;
                    const newPanX =
                      screenCx - (target.x + target.width / 2) * scale;
                    const newPanY =
                      screenCy - (target.y + target.height / 2) * scale;
                    setPan({ x: newPanX, y: newPanY });
                  }

                  // B. AUTO-FOCUS TEXT AREA
                  const element = document.getElementById(
                    `node-input-${nextNodeId}`
                  );
                  if (element) {
                    element.focus();
                    // Optional: Move cursor to end of text
                    // element.setSelectionRange(element.value.length, element.value.length);
                  }
                }, 50);
              };

              const getSameLevelNodes = () => {
                return visibleNodes
                  .filter((n) => n.depth === currentNode.depth)
                  .sort((a, b) => a.y - b.y);
              };

              // TAB: Iterate Same Level (Cycles) - Works even while editing
              if (e.key === "Tab") {
                e.preventDefault();
                const siblings = getSameLevelNodes();
                const currentIndex = siblings.findIndex(
                  (n) => n.id === selectedNodeId
                );
                const nextIndex = (currentIndex + 1) % siblings.length;
                performMove(siblings[nextIndex].id);
                return;
              }

              // CTRL + SHIFT + ARROW UP (Move Up Sibling)
              if (e.ctrlKey && e.shiftKey && e.key === "ArrowUp") {
                e.preventDefault();
                const siblings = getSameLevelNodes();
                const currentIndex = siblings.findIndex(
                  (n) => n.id === selectedNodeId
                );
                if (currentIndex > 0) {
                  performMove(siblings[currentIndex - 1].id);
                }
                return;
              }

              // CTRL + SHIFT + ARROW DOWN (Move Down Sibling)
              if (e.ctrlKey && e.shiftKey && e.key === "ArrowDown") {
                e.preventDefault();
                const siblings = getSameLevelNodes();
                const currentIndex = siblings.findIndex(
                  (n) => n.id === selectedNodeId
                );
                if (currentIndex < siblings.length - 1) {
                  performMove(siblings[currentIndex + 1].id);
                }
                return;
              }

              // CTRL + SHIFT + ARROW LEFT (Go to Parent)
              if (e.ctrlKey && e.shiftKey && e.key === "ArrowLeft") {
                e.preventDefault();
                if (currentNode.parentId) {
                  performMove(currentNode.parentId);
                }
                return;
              }

              // CTRL + SHIFT + ARROW RIGHT (Go to Child)
              if (e.ctrlKey && e.shiftKey && e.key === "ArrowRight") {
                e.preventDefault();

                // 1. Check Visible Children (Already expanded)
                const visibleChildren = visibleNodes
                  .filter((n) => n.parentId === selectedNodeId)
                  .sort((a, b) => a.y - b.y);

                if (visibleChildren.length > 0) {
                  performMove(visibleChildren[0].id);
                } else {
                  // 2. Check Hidden Children (Collapsed)
                  const rawNode = nodes.find((n) => n.id === selectedNodeId);
                  const hasChildren = nodes.some(
                    (n) => n.parentId === selectedNodeId
                  );

                  // If it has children but they are collapsed, EXPAND them first
                  if (hasChildren && rawNode && rawNode.isCollapsed) {
                    const newNodes = nodes.map((n) =>
                      n.id === selectedNodeId ? { ...n, isCollapsed: false } : n
                    );
                    updateNodesWithHistory(newNodes);

                    // Wait for layout update, then select first child
                    setTimeout(() => {
                      const updatedLayout = calculateLayout(newNodes);
                      const children = updatedLayout
                        .filter((n) => n.parentId === selectedNodeId)
                        .sort((a, b) => a.y - b.y);

                      if (children.length > 0) {
                        // Manual logic for freshly expanded nodes
                        const childId = children[0].id;
                        setSelectedNodeId(childId);

                        // Pan Camera
                        const target = children[0];
                        if (target) {
                          const screenCx = (window.innerWidth - 80) / 2;
                          const screenCy = (window.innerHeight + 64) / 2;
                          const newPanX =
                            screenCx - (target.x + target.width / 2) * scale;
                          const newPanY =
                            screenCy - (target.y + target.height / 2) * scale;
                          setPan({ x: newPanX, y: newPanY });
                        }

                        // Focus
                        setTimeout(() => {
                          const el = document.getElementById(
                            `node-input-${childId}`
                          );
                          if (el) el.focus();
                        }, 50);
                      }
                    }, 100);
                  }
                }
                return;
              }
            }
          };

          window.addEventListener("keydown", handleKeyDown);
          return () => window.removeEventListener("keydown", handleKeyDown);
        }, [
          nodes,
          notesData, // Added dependency
          viewMode, // Added dependency
          visibleNodes,
          selectedNodeId,
          handleUndo,
          handleRedo,
          handleUndoNotes, // Added dependency
          handleRedoNotes, // Added dependency
          scale,
        ]);

        // --- STATE: FIND & REPLACE (Global) ---
        const [showSearch, setShowSearch] = useState(false);
        const [searchState, setSearchState] = useState({
          query: "",
          replaceText: "",
          matches: [],
          currentIndex: -1,
        });

        useEffect(() => {
          scaleRef.current = scale;
          panRef.current = pan;
        }, [scale, pan]);

        // --- LAYOUT ENGINE ---
        const calculateLayout = useCallback((currentNodes) => {
          const nodesWithMeta = currentNodes.map((node) => {
            const lines = node.text ? node.text.split("\n") : [""];
            const textLen = Math.max(...lines.map((l) => l.length));
            const lineCount = lines.length;

            const dynamicWidth = Math.max(
              BASE_NODE_WIDTH,
              textLen * CHAR_WIDTH_APPROX + 24
            );
            const dynamicHeight = Math.max(
              MIN_NODE_HEIGHT,
              lineCount * 20 + 24
            );

            const hasChildren = currentNodes.some(
              (n) => n.parentId === node.id
            );
            return {
              ...node,
              width: dynamicWidth,
              height: dynamicHeight,
              hasChildren,
            };
          });

          const buildTree = (parentId) => {
            return nodesWithMeta
              .filter((n) => n.parentId === parentId)
              .map((node) => ({ ...node, children: buildTree(node.id) }));
          };

          const tree = buildTree(null);
          if (tree.length === 0) return nodesWithMeta;

          const levelMaxWidth = {};
          const calculateMetrics = (node, level) => {
            if (!levelMaxWidth[level] || node.width > levelMaxWidth[level]) {
              levelMaxWidth[level] = node.width;
            }
            if (!node.isCollapsed && node.children) {
              node.children.forEach((child) =>
                calculateMetrics(child, level + 1)
              );
            }
          };
          tree.forEach((root) => calculateMetrics(root, 0));

          const levelX = {};
          let currentX = 0;
          const maxLevel = Math.max(...Object.keys(levelMaxWidth).map(Number));
          for (let i = 0; i <= maxLevel; i++) {
            levelX[i] = currentX;
            const maxW = levelMaxWidth[i] || BASE_NODE_WIDTH;
            currentX += maxW + HORIZONTAL_GAP;
          }

          let layoutNodes = [];

          const layoutNode = (node, level, startY) => {
            const x = levelX[level];

            let actualContentHeight = node.height;
            let totalReservedHeight = node.height + VERTICAL_GAP;

            if (
              !node.isCollapsed &&
              node.children &&
              node.children.length > 0
            ) {
              let childStartY = startY;
              let childrenTotalHeight = 0;

              node.children.forEach((child) => {
                const { height } = layoutNode(child, level + 1, childStartY);
                childStartY += height;
                childrenTotalHeight += height;
              });

              actualContentHeight = Math.max(node.height, childrenTotalHeight);
              totalReservedHeight = childrenTotalHeight + SUBTREE_SEPARATION;
            }

            let y = startY;
            if (
              !node.isCollapsed &&
              node.children &&
              node.children.length > 0
            ) {
              const visualChildrenHeight =
                totalReservedHeight - SUBTREE_SEPARATION;
              y = startY + visualChildrenHeight / 2 - node.height / 2;
            }

            const { children, ...nodeData } = node;

            layoutNodes.push({
              ...nodeData,
              x: x,
              y: y,
              depth: level,
              color: node.color || COLORS[level % COLORS.length],
            });

            return { height: totalReservedHeight };
          };

          let currentY = 0;
          tree.forEach((root) => {
            const { height } = layoutNode(root, 0, currentY);
            currentY += height;
          });

          return layoutNodes;
        }, []);

        const visibleNodes = useMemo(() => {
          return calculateLayout(nodes);
        }, [nodes, calculateLayout]);

        // --- HELPERS (Layout/Zoom) ---
        const getBoundingBox = (currentNodes) => {
          if (currentNodes.length === 0)
            return {
              minX: 0,
              maxX: 0,
              minY: 0,
              maxY: 0,
              width: 0,
              height: 0,
              cx: 0,
              cy: 0,
            };
          let minX = Infinity,
            maxX = -Infinity,
            minY = Infinity,
            maxY = -Infinity;
          currentNodes.forEach((n) => {
            minX = Math.min(minX, n.x);
            maxX = Math.max(maxX, n.x + n.width);
            minY = Math.min(minY, n.y);
            maxY = Math.max(maxY, n.y + n.height);
          });
          return {
            minX,
            maxX,
            minY,
            maxY,
            width: maxX - minX,
            height: maxY - minY,
            cx: (minX + maxX) / 2,
            cy: (minY + maxY) / 2,
          };
        };

        const fitView = () => {
          const bounds = getBoundingBox(visibleNodes);
          if (bounds.width === 0) return;
          const padding = 100;
          const availableWidth = window.innerWidth - 80 - padding * 2;
          const availableHeight = window.innerHeight - 64 - 100;
          const scaleX = availableWidth / bounds.width;
          const scaleY = availableHeight / bounds.height;
          const newScale = Math.min(scaleX, scaleY, 1.5);
          const screenCx = (window.innerWidth - 80) / 2;
          const screenCy = (window.innerHeight + 64) / 2;
          const newPanX = screenCx - bounds.cx * newScale;
          const newPanY = screenCy - bounds.cy * newScale;
          setScale(newScale);
          setPan({ x: newPanX, y: newPanY });
        };

        const focusRoot = () => {
          const rootNode = visibleNodes.find((n) => n.id === "root");
          if (!rootNode) return;
          const screenCx = (window.innerWidth - 80) / 2;
          const screenCy = (window.innerHeight + 64) / 2;
          const newPanX = screenCx - rootNode.x * 1;
          const newPanY = screenCy - rootNode.y * 1;
          setScale(1);
          setPan({ x: newPanX, y: newPanY });
        };

        // --- ACTIONS: REORDER ---
        const moveNodeUp = () => {
          if (!selectedNodeId) return;
          const selectedNode = nodes.find((n) => n.id === selectedNodeId);
          if (!selectedNode || !selectedNode.parentId) return;

          const siblings = nodes.filter(
            (n) => n.parentId === selectedNode.parentId
          );
          const myIndex = siblings.findIndex((n) => n.id === selectedNodeId);

          if (myIndex > 0) {
            const newSiblings = [...siblings];
            [newSiblings[myIndex], newSiblings[myIndex - 1]] = [
              newSiblings[myIndex - 1],
              newSiblings[myIndex],
            ];
            const otherNodes = nodes.filter(
              (n) => n.parentId !== selectedNode.parentId
            );

            // SAVE HISTORY
            updateNodesWithHistory([...otherNodes, ...newSiblings]);
          }
        };

        const moveNodeDown = () => {
          if (!selectedNodeId) return;
          const selectedNode = nodes.find((n) => n.id === selectedNodeId);
          if (!selectedNode || !selectedNode.parentId) return;

          const siblings = nodes.filter(
            (n) => n.parentId === selectedNode.parentId
          );
          const myIndex = siblings.findIndex((n) => n.id === selectedNodeId);

          if (myIndex < siblings.length - 1) {
            const newSiblings = [...siblings];
            [newSiblings[myIndex], newSiblings[myIndex + 1]] = [
              newSiblings[myIndex + 1],
              newSiblings[myIndex],
            ];
            const otherNodes = nodes.filter(
              (n) => n.parentId !== selectedNode.parentId
            );

            // SAVE HISTORY
            updateNodesWithHistory([...otherNodes, ...newSiblings]);
          }
        };

        // 1. Manual Toggle (For the little +/- button on the node)
        // Keeps it simple: just toggles that specific node.
        // It DOES NOT recursively open/close children, preserving their state for manual drill-down.
        const toggleCollapse = (nodeId) => {
          const newNodes = nodes.map((n) =>
            n.id === nodeId ? { ...n, isCollapsed: !n.isCollapsed } : n
          );
          updateNodesWithHistory(newNodes);
        };

        const toggleExpandAll = () => {
          const anyCollapsed = nodes.some(
            (n) =>
              n.isCollapsed && nodes.some((child) => child.parentId === n.id)
          );
          if (anyCollapsed) {
            setNodes((prev) => prev.map((n) => ({ ...n, isCollapsed: false })));
          } else {
            setNodes((prev) =>
              prev.map((n) =>
                n.id === "root" ? n : { ...n, isCollapsed: true }
              )
            );
          }
        };

        const addNode = () => {
          if (!selectedNodeId) {
            alert("Please select a parent node first, Ji!");
            return;
          }
          const parent = nodes.find((n) => n.id === selectedNodeId);
          const nodesExpanded = nodes.map((n) =>
            n.id === parent.id ? { ...n, isCollapsed: false } : n
          );

          const nextDepth = (parent.depth || 0) + 1;
          const defaultStyle = "outline"; // Default new node style

          const newNode = {
            id: generateId(),
            text: "",
            parentId: selectedNodeId,
            x: 0,
            y: 0,
            width: BASE_NODE_WIDTH,
            height: MIN_NODE_HEIGHT,
            depth: nextDepth,
            style: defaultStyle,
            color: getColorForLevel(nextDepth, defaultStyle), // Dynamic level-based color
            isCollapsed: false,
          };

          updateNodesWithHistory([...nodesExpanded, newNode]);
          markDirty(selectedNodeId);
        };

        const updateNodeText = (id, newText) => {
          const newNodes = nodes.map((n) =>
            n.id === id ? { ...n, text: newText } : n
          );
          updateNodesWithHistory(newNodes);
          markDirty(id); // <--- Yeh bhi sahi se chalega
        };

        const deleteNode = () => {
          if (!selectedNodeId || selectedNodeId === "root") return;
          const parentId = nodes.find((n) => n.id === selectedNodeId)?.parentId;

          const getDescendants = (id) => {
            let descendants = [];
            nodes.forEach((n) => {
              if (n.parentId === id) {
                descendants.push(n.id);
                descendants = [...descendants, ...getDescendants(n.id)];
              }
            });
            return descendants;
          };
          const idsToDelete = [
            selectedNodeId,
            ...getDescendants(selectedNodeId),
          ];

          updateNodesWithHistory(
            nodes.filter((n) => !idsToDelete.includes(n.id))
          );
          markDirty(parentId); // Highlight parent branch after deletion
          setSelectedNodeId(null);
        };

        // 5. COLOR UPDATES
        const updateSingleColor = (color) => {
          setNodeColor(color);
          if (!selectedNodeId) return;
          const newNodes = nodes.map((n) =>
            n.id === selectedNodeId ? { ...n, color: color } : n
          );
          updateNodesWithHistory(newNodes);
        };

        const updateGroupColor = (color) => {
          setNodeColor(color);
          if (!selectedNodeId) return;
          const selectedNode = nodes.find((n) => n.id === selectedNodeId);
          if (!selectedNode) return;
          const parentId = selectedNode.parentId;

          const newNodes = nodes.map((n) => {
            if (
              n.id === selectedNodeId ||
              (parentId !== null && n.parentId === parentId)
            ) {
              return { ...n, color: color };
            }
            return n;
          });
          updateNodesWithHistory(newNodes);
        };

        const updateLevelColor = (color) => {
          setNodeColor(color);
          if (!selectedNodeId) return;

          const getNodeDepth = (nodeId, allNodes) => {
            let depth = 0;
            let current = allNodes.find((n) => n.id === nodeId);
            while (current && current.parentId) {
              depth++;
              current = allNodes.find((n) => n.id === current.parentId);
            }
            return depth;
          };

          const targetDepth = getNodeDepth(selectedNodeId, nodes);
          const newNodes = nodes.map((n) => {
            const myDepth = getNodeDepth(n.id, nodes);
            if (myDepth === targetDepth) {
              return { ...n, color: color };
            }
            return n;
          });
          updateNodesWithHistory(newNodes);
        };

        // --- STYLE UPDATES (Logic split for Dialog) ---

        // 1. Open Dialog
        const openStyleDialog = (styleType) => {
          if (!selectedNodeId) {
            alert("Please select a node first, Ji!");
            return;
          }
          setPendingStyleType(styleType);
          setStyleDialogOpen(true);
        };

        // 6. STYLE UPDATES
        // When changing only the selected node's style:
        const updateNodeStyleOnly = () => {
          if (!selectedNodeId || !pendingStyleType) return;
          const newNodes = nodes.map((n) => {
            if (n.id === selectedNodeId) {
              return {
                ...n,
                style: pendingStyleType,
                color: getColorForLevel(n.depth, pendingStyleType),
              };
            }
            return n;
          });
          updateNodesWithHistory(newNodes);
          setStyleDialogOpen(false);
        };

        const updateSiblingStyle = () => {
          if (!selectedNodeId || !pendingStyleType) return;
          const selectedNode = nodes.find((n) => n.id === selectedNodeId);
          if (!selectedNode) return;
          const parentId = selectedNode.parentId;

          const newNodes = nodes.map((n) => {
            if (
              n.id === selectedNodeId ||
              (parentId !== null && n.parentId === parentId)
            ) {
              return {
                ...n,
                style: pendingStyleType,
                color: getColorForLevel(n.depth, pendingStyleType),
              };
            }
            return n;
          });
          updateNodesWithHistory(newNodes);
          setStyleDialogOpen(false);
        };

        const updateLevelStyle = () => {
          if (!selectedNodeId || !pendingStyleType) return;
          const selectedNode = nodes.find((n) => n.id === selectedNodeId);
          if (!selectedNode) return;

          // Calculate target depth
          let targetDepth = 0;
          let curr = selectedNode;
          while (curr && curr.parentId) {
            targetDepth++;
            curr = nodes.find((x) => x.id === curr.parentId);
          }

          const newNodes = nodes.map((n) => {
            let nodeDepth = 0;
            let nodeCurr = n;
            while (nodeCurr && nodeCurr.parentId) {
              nodeDepth++;
              nodeCurr = nodes.find((x) => x.id === nodeCurr.parentId);
            }

            if (nodeDepth === targetDepth) {
              return {
                ...n,
                style: pendingStyleType,
                color: getColorForLevel(nodeDepth, pendingStyleType),
              };
            }
            return n;
          });
          updateNodesWithHistory(newNodes);
          setStyleDialogOpen(false);
        };

        // --- MOVE & COPY NODE LOGIC ---
        const startMoveNode = () => {
          if (!selectedNodeId) {
            alert("Please select a node to move first, Ji!");
            return;
          }
          if (selectedNodeId === "root") {
            alert("Cannot move the Central Idea (Root)!");
            return;
          }
          setMovingNodeId(selectedNodeId);
          setIsMoveMode(true);
          setSelectedNodeId(null); // Deselect to allow clicking new parent
        };

        const cancelMoveNode = () => {
          setIsMoveMode(false);
          setMovingNodeId(null);
        };

        // --- LEVEL-BY-LEVEL EXPAND/COLLAPSE HELPERS ---

        // Helper: Get max depth of currently visible descendants for a node
        const getVisibleDepth = useCallback((nodeId, allNodes) => {
          const children = allNodes.filter(
            (n) => n.parentId === nodeId && !n.isCollapsed
          );
          if (children.length === 0) return 0;
          const depths = children.map(
            (child) => 1 + getVisibleDepth(child.id, allNodes)
          );
          return Math.max(...depths);
        }, []);

        // Helper: Get all descendants recursively
        const getAllDescendants = useCallback((nodeId, allNodes) => {
          let descendants = [];
          allNodes.forEach((n) => {
            if (n.parentId === nodeId) {
              descendants.push(n);
              descendants = [
                ...descendants,
                ...getAllDescendants(n.id, allNodes),
              ];
            }
          });
          return descendants;
        }, []);

        // EXPAND NEXT LEVEL (Ctrl + Shift + [)
        const expandNextLevel = useCallback(
          (nodeId) => {
            // 1. If node itself is collapsed, expand it first
            const node = nodes.find((n) => n.id === nodeId);
            if (node && node.isCollapsed) {
              updateNodesWithHistory(
                nodes.map((n) =>
                  n.id === nodeId ? { ...n, isCollapsed: false } : n
                )
              );
              return;
            }

            // 2. Find immediate children that are collapsed
            const immediateChildren = nodes.filter(
              (n) => n.parentId === nodeId
            );
            const collapsedChildren = immediateChildren.filter(
              (n) => n.isCollapsed
            );

            if (collapsedChildren.length > 0) {
              // Expand immediate children (Level 1)
              const newNodes = nodes.map((n) =>
                n.parentId === nodeId ? { ...n, isCollapsed: false } : n
              );
              updateNodesWithHistory(newNodes);
            } else {
              // 3. If immediate children are open, go deeper
              const descendants = getAllDescendants(nodeId, nodes);

              // Find visible descendants (parents are expanded) that are themselves collapsed
              const visibleDescendants = descendants.filter((d) => {
                const parent = nodes.find((p) => p.id === d.parentId);
                return parent && !parent.isCollapsed && d.isCollapsed;
              });

              if (visibleDescendants.length > 0) {
                // Find the minimum depth among these candidates to expand just the next layer
                const minDepth = Math.min(
                  ...visibleDescendants.map((n) => n.depth)
                );

                const newNodes = nodes.map((n) => {
                  if (
                    n.depth === minDepth &&
                    descendants.some((d) => d.id === n.id)
                  ) {
                    return { ...n, isCollapsed: false };
                  }
                  return n;
                });
                updateNodesWithHistory(newNodes);
              }
            }
          },
          [nodes, getAllDescendants]
        ); // Dependencies

        // COLLAPSE ONE LEVEL (Ctrl + Shift + ])
        const collapseOneLevel = useCallback(
          (nodeId) => {
            const descendants = getAllDescendants(nodeId, nodes);

            // Find deepest level that is currently visible
            const visibleParents = descendants.filter(
              (n) => !n.isCollapsed && nodes.some((c) => c.parentId === n.id)
            );

            if (visibleParents.length > 0) {
              // Collapse the deepest expanded nodes
              const maxDepth = Math.max(...visibleParents.map((n) => n.depth));
              const newNodes = nodes.map((n) => {
                if (
                  n.depth === maxDepth &&
                  visibleParents.some((vp) => vp.id === n.id)
                ) {
                  return { ...n, isCollapsed: true };
                }
                return n;
              });
              updateNodesWithHistory(newNodes);
            } else {
              // If no descendants are expanded, collapse the node itself
              const hasChildren = nodes.some((n) => n.parentId === nodeId);
              if (hasChildren) {
                updateNodesWithHistory(
                  nodes.map((n) =>
                    n.id === nodeId ? { ...n, isCollapsed: true } : n
                  )
                );
              }
            }
          },
          [nodes, getAllDescendants]
        ); // Dependencies

        // --- 1. STATE DEFINITION (Put at top of App) ---
        const [moveCopyDialog, setMoveCopyDialog] = useState({
          isOpen: false,
          sourceId: null,
          targetId: null,
        });

        // --- 2. LOGIC FUNCTIONS (Replace/Add these in App) ---

        // A. Trigger Logic (Validation & Open Dialog)
        const completeMoveNode = (newParentId) => {
          if (!isMoveMode || !movingNodeId) return;
          if (movingNodeId === newParentId) {
            alert("Cannot move a node to itself, Ji!");
            return;
          }

          const isDescendant = (childId, rootId) => {
            if (childId === rootId) return true;
            const node = nodes.find((n) => n.id === childId);
            if (!node || !node.parentId) return false;
            return isDescendant(node.parentId, rootId);
          };

          if (isDescendant(newParentId, movingNodeId)) {
            alert("Cannot move a node inside its own branch!");
            return;
          }

          // Open Dialog instead of moving immediately
          setMoveCopyDialog({
            isOpen: true,
            sourceId: movingNodeId,
            targetId: newParentId,
          });
        };

        // B. Execute Move (The original logic, now wrapped)
        const executeMove = () => {
          const { sourceId, targetId } = moveCopyDialog;
          if (!sourceId || !targetId) return;

          const newNodes = nodes.map((n) =>
            n.id === sourceId ? { ...n, parentId: targetId } : n
          );

          // Re-calculate ALL depths and colors
          const finalNodes = newNodes.map((n) => {
            let depth = 0;
            let curr = n;
            while (curr && curr.parentId) {
              depth++;
              curr = newNodes.find((x) => x.id === curr.parentId);
            }
            return { ...n, depth, color: getColorForLevel(depth, n.style) };
          });

          updateNodesWithHistory(finalNodes);

          // Reset States
          setMoveCopyDialog({ isOpen: false, sourceId: null, targetId: null });
          setIsMoveMode(false);
          setMovingNodeId(null);
          setSelectedNodeId(sourceId);
        };

        // C. Execute Copy (New Branch Cloning Logic)
        const executeCopy = () => {
          const { sourceId, targetId } = moveCopyDialog;
          if (!sourceId || !targetId) return;

          const sourceNode = nodes.find((n) => n.id === sourceId);
          if (!sourceNode) return;

          // Helper to get descendants
          const getDescendants = (parentId, allNodes) => {
            let list = [];
            allNodes.forEach((n) => {
              if (n.parentId === parentId) {
                list.push(n);
                list = [...list, ...getDescendants(n.id, allNodes)];
              }
            });
            return list;
          };

          const descendants = getDescendants(sourceId, nodes);
          const branchToClone = [sourceNode, ...descendants];

          // Map old IDs to new IDs
          const idMap = {};
          branchToClone.forEach((node) => {
            idMap[node.id] = generateId();
          });

          // Calculate depth offset
          const targetParent = nodes.find((n) => n.id === targetId);
          const targetDepth = targetParent ? targetParent.depth || 0 : 0;
          const depthOffset = targetDepth + 1 - sourceNode.depth;

          const newNodes = branchToClone.map((node) => {
            const newId = idMap[node.id];
            // If root of branch, use targetId. Else use mapped parent.
            const newParentId =
              node.id === sourceId ? targetId : idMap[node.parentId];

            const newDepth = node.depth + depthOffset;

            return {
              ...node,
              id: newId,
              text: node.text,
              parentId: newParentId,
              depth: newDepth,
              color: getColorForLevel(newDepth, node.style),
              x: node.x + 20,
              y: node.y + 20,
            };
          });

          updateNodesWithHistory([...nodes, ...newNodes]);

          // Reset States
          setMoveCopyDialog({ isOpen: false, sourceId: null, targetId: null });
          setIsMoveMode(false);
          setMovingNodeId(null);
          // Select the new root copy
          setSelectedNodeId(idMap[sourceId]);
        };

        // Custom Click Handler wrapper
        const handleNodeClickWrapper = (nodeId, e) => {
          e.stopPropagation();
          if (isMoveMode) {
            completeMoveNode(nodeId);
          } else {
            setSelectedNodeId(nodeId);
          }
        };

        useEffect(() => {
          if (selectedNodeId) {
            const node = nodes.find((n) => n.id === selectedNodeId);
            if (node) setNodeColor(node.color || COLORS[0]);
          }
        }, [selectedNodeId, nodes]);

        // --- HELPER: Re-index Labels ---
        // This function renames all notes to Statement 1, Statement 2, etc. based on order
        const reindexNotes = (list) => {
          return list.map((note, i) => ({
            ...note,
            label: `Statement ${i + 1}`,
          }));
        };

        // --- ACTIONS: NOTES ---

        const updateNote = (id, updates) => {
          const newNotes = notesData.map((n) =>
            n.id === id ? { ...n, ...updates } : n
          );
          // Only save history if the text changed significantly or on blur
          // For simplicity, we save history. For input optimization, you might debounce this.
          // But for buttons/toggles, this is perfect.
          updateNotesWithHistory(newNotes);
        };

        const addNote = () => {
          const newNote = {
            id: generateId(),
            text: "",
            color: COLORS[notesData.length % COLORS.length],
            style: "outline",
            label: `Statement ${notesData.length + 1}`,
            isCollapsed: false,
          };
          updateNotesWithHistory([...notesData, newNote]);
        };

        const deleteNote = (id) => {
          const remaining = notesData.filter((n) => n.id !== id);
          updateNotesWithHistory(reindexNotes(remaining));
        };

        const moveNoteUpInList = (index) => {
          if (index === 0) return;
          const newNotes = [...notesData];
          [newNotes[index], newNotes[index - 1]] = [
            newNotes[index - 1],
            newNotes[index],
          ];
          updateNotesWithHistory(reindexNotes(newNotes));
        };

        const moveNoteDownInList = (index) => {
          if (index === notesData.length - 1) return;
          const newNotes = [...notesData];
          [newNotes[index], newNotes[index + 1]] = [
            newNotes[index + 1],
            newNotes[index],
          ];
          updateNotesWithHistory(reindexNotes(newNotes));
        };

        // --- HELPER: DOWNLOAD SVG FILE ---
        const downloadSVGFile = (svgElement, filename) => {
          const serializer = new XMLSerializer();
          // Add XML declaration and namespaces
          let source = serializer.serializeToString(svgElement);
          if (
            !source.match(/^<svg[^>]+xmlns="http\:\/\/www\.w3\.org\/2000\/svg"/)
          ) {
            source = source.replace(
              /^<svg/,
              '<svg xmlns="http://www.w3.org/2000/svg"'
            );
          }
          if (
            !source.match(
              /^<svg[^>]+xmlns\:xlink="http\:\/\/www\.w3\.org\/1999\/xlink"/
            )
          ) {
            source = source.replace(
              /^<svg/,
              '<svg xmlns:xlink="http://www.w3.org/1999/xlink"'
            );
          }

          const header = '<?xml version="1.0" standalone="no"?>\r\n';
          const svgBlob = new Blob([header + source], {
            type: "image/svg+xml;charset=utf-8",
          });
          const url = URL.createObjectURL(svgBlob);
          const link = document.createElement("a");
          link.href = url;
          link.download = filename;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
        };

        // --- UPDATED EXPORT FUNCTION (Paste inside App component) ---
        const handleDownloadNotes = async (format = "png") => {
          setIsExportingNotes(true);

          // Wait for the hidden container to be populated properly
          setTimeout(async () => {
            try {
              const element = document.getElementById("notes-export-container");
              if (!element) return;

              // 1. DYNAMIC WIDTH & HEIGHT PRE-CALCULATION
              element.style.width = "auto";
              element.style.height = "auto"; // Ensure height is not restricted
              element.style.display = "inline-block";

              // Determine width based on content
              const contentWidth = Math.max(element.scrollWidth + 100, 1000);

              // FIXED: Greatly increased height buffer to prevent cut-off at bottom
              // SVG rendering can sometimes vary in height calculation, so +2000 is safer
              const contentHeight = element.scrollHeight + 2000;

              // Force these dimensions for capture
              element.style.width = `${contentWidth}px`;
              element.style.display = "block";

              // Force borders for export visibility & FIX TABLE WIDTH
              const tables = element.querySelectorAll("table");
              tables.forEach((table) => {
                table.style.borderCollapse = "collapse";
                // FIXED: Changed from "100%" to "auto" to respect column widths
                table.style.width = "auto";
                table.querySelectorAll("td, th").forEach((cell) => {
                  cell.style.border = "1px solid #cbd5e1";
                  cell.style.padding = "12px";
                });
              });

              if (format === "svg") {
                const tailwindStyles = Array.from(document.styleSheets)
                  .filter(
                    (sheet) => !sheet.href || !sheet.href.includes("google")
                  )
                  .reduce((acc, sheet) => {
                    try {
                      return (
                        acc +
                        Array.from(sheet.cssRules).reduce(
                          (a, rule) => a + rule.cssText,
                          ""
                        )
                      );
                    } catch (e) {
                      return acc;
                    }
                  }, "");

                const svgWrapper = document.createElementNS(
                  "http://www.w3.org/2000/svg",
                  "svg"
                );
                svgWrapper.setAttribute("width", contentWidth);
                svgWrapper.setAttribute("height", contentHeight);
                svgWrapper.setAttribute(
                  "viewBox",
                  `0 0 ${contentWidth} ${contentHeight}`
                );

                const styleElement = document.createElementNS(
                  "http://www.w3.org/2000/svg",
                  "style"
                );

                const systemFontStack =
                  '"Inter", ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"';

                styleElement.textContent = `
        /* SVG MAIN CONTAINER STYLING */
        .svg-root {
          background-color: #f8fafc;
          width: 100%;
          height: auto;
          min-height: 100%;
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: flex-start;
          padding: 50px 0;
          margin: 0;
          box-sizing: border-box;
          font-family: ${systemFontStack};
        }

        .svg-content-wrapper {
          width: 90%;
          max-width: ${contentWidth - 100}px;
          margin: 0 auto;
          display: block;
        }

        /* FORCE FONT ON TABLES AND HEADINGS */
        table, th, td, h1, h2, h3, h4, h5, h6, .font-sans {
          font-family: ${systemFontStack} !important;
        }

        /* Ensure tables don't stretch in SVG either */
        table {
          width: auto !important;
        }

        ${tailwindStyles}
      `;
                svgWrapper.appendChild(styleElement);

                const foreignObject = document.createElementNS(
                  "http://www.w3.org/2000/svg",
                  "foreignObject"
                );

                foreignObject.setAttribute("x", "0");
                foreignObject.setAttribute("y", "0");
                foreignObject.setAttribute("width", "100%");
                foreignObject.setAttribute("height", "100%");

                const div = document.createElement("div");
                div.setAttribute("xmlns", "http://www.w3.org/1999/xhtml");
                div.style.width = "100%";
                div.style.height = "100%";

                div.innerHTML = `
        <div class="svg-root">
          <div class="svg-content-wrapper">
            ${element.innerHTML}
          </div>
        </div>
      `;

                foreignObject.appendChild(div);
                svgWrapper.appendChild(foreignObject);

                downloadSVGFile(
                  svgWrapper,
                  `searchable-notes-${Date.now()}.svg`
                );
              } else {
                const canvas = await html2canvas(element, {
                  backgroundColor: "#f8fafc",
                  scale: 2,
                  useCORS: true,
                  width: contentWidth,
                  height: element.scrollHeight, // Capture full height
                  windowWidth: contentWidth,
                });
                const link = document.createElement("a");
                link.download = `notes-full-res-${Date.now()}.png`;
                link.href = canvas.toDataURL("image/png");
                link.click();
              }

              // RESET
              element.style.width = "800px";
              tables.forEach((t) => {
                t.style.borderCollapse = "";
                t.style.width = ""; // Remove forced width
              });
            } catch (e) {
              console.error("Export Error:", e);
              alert("Oops! Export fail ho gaya Ji. Please try again.");
            } finally {
              setIsExportingNotes(false);
            }
          }, 600);
        };

        // --- SAVE / LOAD ---
        const handleSaveProject = async () => {
          // 1. CHECK DIRTY STATE
          const shouldShowToast = isDirty || !currentFileHandle;

          const rootNode = nodes.find((n) => n.id === "root");
          const cleanName =
            rootNode && rootNode.text
              ? rootNode.text.replace(/[/\\?%*:|"<>]/g, "-").trim()
              : "mindmap-project";
          const fileName = `${cleanName}.json`;

          const projectDataObj = {
            version: 2,
            mindMap: nodes,
            notes: notesData,
          };
          const projectData = JSON.stringify(projectDataObj, null, 2);

          let isSavedSuccessfully = false;
          let savedPathDisplay = "";

          // 2. TRY OVERWRITE (Existing Handle)
          if (currentFileHandle) {
            try {
              const writable = await currentFileHandle.createWritable();
              await writable.write(projectData);
              await writable.close();
              isSavedSuccessfully = true;
              savedPathDisplay = currentFileHandle.name;
              console.log("Saved to original file location, Ji!");
            } catch (err) {
              console.warn("Lost access, falling back...");
            }
          }

          // 3. MODERN 'SAVE AS' (Picker)
          if (!isSavedSuccessfully && window.showSaveFilePicker) {
            try {
              const handle = await window.showSaveFilePicker({
                suggestedName: fileName,
                types: [
                  {
                    description: "MindMap Project File",
                    accept: { "application/json": [".json"] },
                  },
                ],
              });
              const writable = await handle.createWritable();
              await writable.write(projectData);
              await writable.close();

              setCurrentFileHandle(handle);
              isSavedSuccessfully = true;
              savedPathDisplay = handle.name;
            } catch (err) {
              if (err.name !== "AbortError") console.error("Save failed:", err);
              else return;
            }
          }

          // 4. LEGACY DOWNLOAD (Downloads Folder)
          if (!isSavedSuccessfully) {
            try {
              const blob = new Blob([projectData], {
                type: "application/json",
              });
              const url = URL.createObjectURL(blob);
              const link = document.createElement("a");
              link.download = fileName;
              link.href = url;
              document.body.appendChild(link);
              link.click();
              document.body.removeChild(link);
              isSavedSuccessfully = true;

              // Explicitly mention Downloads for this fallback
              savedPathDisplay = `Downloads/${fileName}`;
            } catch (err) {
              console.error("Fallback Save failed:", err);
            }
          }

          if (isSavedSuccessfully) {
            setIsDirty(false);
            setDirtyLevel1Nodes(new Set());
            setHistory({ past: [], future: [] });
            setNotesHistory({ past: [], future: [] });

            if (shouldShowToast) {
              // Message format
              showToast(`Changes saved to ${savedPathDisplay}`);
            }
          }
        };

        // --- UPDATED SHORTCUT LISTENER (FIXED DEPENDENCIES) ---
        useEffect(() => {
          const handleKeyDown = (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === "s") {
              e.preventDefault();
              handleSaveProject();
            }
          };
          window.addEventListener("keydown", handleKeyDown);
          return () => window.removeEventListener("keydown", handleKeyDown);
        }, [nodes, notesData, isDirty, currentFileHandle]); // <--- CRITICAL FIX: Added dependencies so it knows when isDirty changes

        const handleLoadProject = (e) => {
          const file = e.target.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = (event) => {
            try {
              const loadedData = JSON.parse(event.target.result);

              if (Array.isArray(loadedData)) {
                setNodes(loadedData);
                setNotesData([]);
              } else if (loadedData.version === 2 || loadedData.mindMap) {
                setNodes(loadedData.mindMap || []);
                setNotesData(loadedData.notes || []);
              } else {
                alert("Invalid project format, Ji.");
                return;
              }

              // AFTER LOAD:
              setIsDirty(false);
              setDirtyLevel1Nodes(new Set());
              setHistory({ past: [], future: [] }); // Reset Map History
              setNotesHistory({ past: [], future: [] }); // Reset Notes History <--- NEW

              setTimeout(() => {
                if (viewMode === "map") fitView();
              }, 100);
            } catch (err) {
              console.error(err);
              alert("Error loading project file, Bhai.");
            }
          };
          reader.readAsText(file);
          if (projectInputRef.current) projectInputRef.current.value = "";
        };

        // --- NEW HANDLER: Open File via System Picker ---
        const handleOpenProjectPicker = async () => {
          if (window.showOpenFilePicker) {
            try {
              const [handle] = await window.showOpenFilePicker({
                startIn: "downloads", // <--- Force start in Downloads folder
                types: [
                  {
                    description: "MindMap Project File",
                    accept: { "application/json": [".json"] },
                  },
                ],
                multiple: false,
              });

              const file = await handle.getFile();
              const contents = await file.text();

              // Call your existing load logic
              // Note: Ensure loadProjectData is defined or copy the logic inside here
              const loadedData = JSON.parse(contents);
              if (Array.isArray(loadedData)) {
                setNodes(loadedData);
                setNotesData([]);
              } else {
                setNodes(loadedData.mindMap || []);
                setNotesData(loadedData.notes || []);
              }

              // IMPORTANT: Save the handle so we can overwrite later!
              setCurrentFileHandle(handle);

              // Reset histories
              setIsDirty(false);
              setDirtyLevel1Nodes(new Set());
              setHistory({ past: [], future: [] });
              setNotesHistory({ past: [], future: [] });
            } catch (err) {
              if (err.name !== "AbortError") {
                console.error("Open failed:", err);
                // Fallback if picker fails
                if (projectInputRef.current) projectInputRef.current.click();
              }
            }
          } else {
            // Fallback for older browsers
            if (projectInputRef.current) projectInputRef.current.click();
          }
        };

        // --- UPDATED: DOWNLOAD MINDMAP (Fixed: Injects Inter Font & Medium Weight) ---
        const handleDownloadMindMap = async (format = "png") => {
          setIsDownloading(true);

          const bounds = getBoundingBox(visibleNodes);

          const padding = 50;

          const config = {
            width: bounds.width + padding * 2,

            height: bounds.height + padding * 2,

            offsetX: -bounds.minX + padding,

            offsetY: -bounds.minY + padding,
          };

          setExportConfig(config);

          // Wait for render

          setTimeout(async () => {
            try {
              const element = document.getElementById("export-container");

              if (!element) throw new Error("Export container not found");

              if (format === "svg") {
                const svgElement = element.querySelector("svg");

                // --- FIX: CLONE & INJECT FONT STYLES ---

                // We clone the SVG so we can modify it without messing up the hidden container

                const clonedSvg = svgElement.cloneNode(true);

                // Create a style element to force the font inside the SVG file

                const style = document.createElementNS(
                  "http://www.w3.org/2000/svg",
                  "style"
                );

                // Use "Inter" and weight 500 (Medium) to match the Node Editor's look

                style.textContent = `

                  text {

                    font-family: "Inter", sans-serif;

                    font-weight: 500;

                  }

                `;

                // Add the style to the top of the SVG

                clonedSvg.prepend(style);

                downloadSVGFile(clonedSvg, `mindmap-${Date.now()}.svg`);
              } else {
                const canvas = await html2canvas(element, {
                  backgroundColor: "#ffffff",

                  scale: 2,

                  logging: false,
                });

                const dataUrl = canvas.toDataURL("image/png");

                const link = document.createElement("a");

                link.download = `mindmap-${Date.now()}.png`;

                link.href = dataUrl;

                document.body.appendChild(link);

                link.click();

                document.body.removeChild(link);
              }
            } catch (error) {
              console.error(error);

              alert("Export failed, Ji.");
            } finally {
              setIsDownloading(false);

              setExportConfig(null);
            }
          }, 500);
        };

        const handleFileUpload = (e) => {
          const file = e.target.files[0];
          if (!file) return;
          setIsProcessing(true);
          setTimeout(() => {
            const mockParsedNodes = [
              {
                id: "root",
                text: "Project Alpha",
                parentId: null,
                isCollapsed: false,
                depth: 0,
                height: 50,
                width: 140,
              },
              {
                id: "1",
                text: "Research Phase",
                parentId: "root",
                isCollapsed: false,
                depth: 1,
                height: 50,
                width: 140,
              },
            ];
            setNodes(mockParsedNodes);
            setIsProcessing(false);
            setTimeout(() => fitView(), 100);
            if (fileInputRef.current) fileInputRef.current.value = "";
          }, 2000);
        };

        // --- CANVAS INTERACTION ---
        useEffect(() => {
          const canvas = canvasRef.current;
          if (!canvas) return;

          const onWheel = (e) => {
            if (e.ctrlKey && viewMode === "map") {
              e.preventDefault();
              e.stopPropagation();

              const container = canvas.getBoundingClientRect();
              const mouseX = e.clientX - container.left;
              const mouseY = e.clientY - container.top;

              const zoomSensitivity = 0.002;
              const delta = -e.deltaY * zoomSensitivity;

              const currentScale = scaleRef.current;
              const currentPan = panRef.current;

              const newScale = Math.min(
                Math.max(0.05, currentScale + delta),
                5
              );

              const scaleRatio = newScale / currentScale;
              const newPanX = mouseX - (mouseX - currentPan.x) * scaleRatio;
              const newPanY = mouseY - (mouseY - currentPan.y) * scaleRatio;

              setScale(newScale);
              setPan({ x: newPanX, y: newPanY });
            }
          };

          canvas.addEventListener("wheel", onWheel, { passive: false });

          return () => {
            canvas.removeEventListener("wheel", onWheel);
          };
        }, [viewMode]);

        const startPan = (e) => {
          if (isDraggingRoot) return;
          const isInteractive =
            e.target.closest("input") ||
            e.target.closest("button") ||
            e.target.closest("textarea");
          if (!isInteractive) {
            setIsDraggingCanvas(true);
            setDragStart({ x: e.clientX - pan.x, y: e.clientY - pan.y });
          }
        };

        const handleNodeMouseDown = (e, nodeId) => {
          if (nodeId === "root") {
            e.stopPropagation();
            setIsDraggingRoot(true);
            setDragStart({ x: e.clientX - pan.x, y: e.clientY - pan.y });
          }
        };

        const doPan = (e) => {
          if (isDraggingCanvas || isDraggingRoot) {
            setPan({ x: e.clientX - dragStart.x, y: e.clientY - dragStart.y });
          }
        };

        const endPan = () => {
          setIsDraggingCanvas(false);
          setIsDraggingRoot(false);
        };

        useEffect(() => {
          if (viewMode === "map") fitView();
        }, []);

        // --- GLOBAL SHORTCUTS (Ctrl+` / Ctrl+Alt+R) ---
        useEffect(() => {
          const handleGlobalKeyDown = (e) => {
            if (
              (e.ctrlKey && e.key === "`") ||
              (e.ctrlKey &&
                e.altKey &&
                (e.key.toLowerCase() === "r" || e.key.toLowerCase() === "f"))
            ) {
              e.preventDefault();
              // TOGGLE LOGIC: If open, close it (clean). If closed, open it.
              if (showSearch) {
                handleCloseSearch();
              } else {
                setShowSearch(true);
              }
            }
            // CLOSE: Escape
            if (e.key === "Escape") {
              handleCloseSearch(); // Use clean close
            }
          };
          window.addEventListener("keydown", handleGlobalKeyDown);
          return () =>
            window.removeEventListener("keydown", handleGlobalKeyDown);
        }, [showSearch, handleCloseSearch]); // Added dependencies

        // --- NEW HELPER: CLOSE AND CLEAR SEARCH ---
        const handleCloseSearch = useCallback(() => {
          setShowSearch(false);
          // Clear values so next time it is blank
          setSearchState({
            query: "",
            replaceText: "",
            matches: [],
            currentIndex: -1,
          });
        }, []);

        // --- NEW HELPER: SWITCH VIEW AND CLEAR SEARCH ---
        const handleSwitchView = (mode) => {
          if (viewMode !== mode) {
            setViewMode(mode);
            handleCloseSearch(); // Close search when changing pages
          }
        };

        // --- SMART SEARCH LOGIC (Ignores Hidden Nodes) ---
        useEffect(() => {
          if (!searchState.query) {
            setSearchState((prev) => ({
              ...prev,
              matches: [],
              currentIndex: -1,
            }));
            return;
          }
          const query = searchState.query.toLowerCase();

          let source = [];

          if (viewMode === "map") {
            // Helper from visibleNodes calculation logic
            // Easier way: Use the 'visibleNodes' we already calculated for rendering!
            // visibleNodes only contains nodes that are NOT collapsed.
            source = visibleNodes;
          } else {
            source = notesData;
          }

          const newMatches = source
            .filter(
              (item) => item.text && item.text.toLowerCase().includes(query)
            )
            .map((item) => item.id);

          setSearchState((prev) => ({
            ...prev,
            matches: newMatches,
            // Reset index if matches changed significantly, or try to keep position
            currentIndex: newMatches.length > 0 ? 0 : -1,
          }));
        }, [searchState.query, visibleNodes, notesData, viewMode]); // Depend on visibleNodes

        // --- HANDLERS ---
        const scrollToMatch = (index) => {
          const matchId = searchState.matches[index];
          if (!matchId) return;

          if (viewMode === "notes") {
            const el = document.getElementById(`note-${matchId}`);
            if (el) el.scrollIntoView({ behavior: "smooth", block: "center" });
          } else {
            // Map View: Pan to Node
            const node = visibleNodes.find((n) => n.id === matchId);
            if (node) {
              setSelectedNodeId(node.id);
              const screenCx = (window.innerWidth - 80) / 2;
              const screenCy = (window.innerHeight + 64) / 2;
              const newPanX = screenCx - (node.x + node.width / 2) * scale;
              const newPanY = screenCy - (node.y + node.height / 2) * scale;
              setPan({ x: newPanX, y: newPanY });
            }
          }
        };

        const handleSearchNext = () => {
          if (searchState.matches.length === 0) return;
          const nextIndex =
            (searchState.currentIndex + 1) % searchState.matches.length;
          setSearchState((prev) => ({ ...prev, currentIndex: nextIndex }));
          scrollToMatch(nextIndex);
        };

        const handleSearchPrev = () => {
          if (searchState.matches.length === 0) return;
          const prevIndex =
            (searchState.currentIndex - 1 + searchState.matches.length) %
            searchState.matches.length;
          setSearchState((prev) => ({ ...prev, currentIndex: prevIndex }));
          scrollToMatch(prevIndex);
        };

        // 8. FIND & REPLACE (Fixed for Blocks & Tables)
        const handleReplace = () => {
          if (searchState.currentIndex === -1) return;
          const currentId = searchState.matches[searchState.currentIndex];

          if (viewMode === "map") {
            // Map Logic (Unchanged)
            const node = nodes.find((n) => n.id === currentId);
            if (node) {
              const newText = node.text.replace(
                searchState.query,
                searchState.replaceText
              );
              updateNodeText(currentId, newText);
            }
          } else {
            // Notes Logic (Updated for Blocks)
            const note = notesData.find((n) => n.id === currentId);
            if (note) {
              let newNotes = [];

              // Case A: Modern Note with Blocks
              if (note.blocks && note.blocks.length > 0) {
                let replaced = false;
                // Loop through blocks to find the first match
                const newBlocks = note.blocks.map((block) => {
                  // Only replace in the first matching text block we find
                  // (This mimics standard "Replace One" behavior)
                  if (
                    !replaced &&
                    block.type === "text" &&
                    block.content.includes(searchState.query)
                  ) {
                    const newContent = block.content.replace(
                      searchState.query,
                      searchState.replaceText
                    );
                    replaced = true;
                    return { ...block, content: newContent };
                  }
                  return block;
                });

                // Re-generate sync text for search indexing
                const newLegacyText = newBlocks
                  .map((b) => {
                    if (b.type === "text") return b.content;
                    if (b.type === "table") {
                      // Keep table structure in legacy text
                      if (b.data) {
                        const headers = `| ${b.data.headers.join(" | ")} |`;
                        const rows = b.data.rows
                          .map((row) => `| ${row.join(" | ")} |`)
                          .join("\n");
                        return `${headers}\n${rows}`;
                      }
                      return "[Table]";
                    }
                    return "";
                  })
                  .join("\n\n");

                newNotes = notesData.map((n) =>
                  n.id === currentId
                    ? { ...n, blocks: newBlocks, text: newLegacyText }
                    : n
                );
              }
              // Case B: Legacy Note (Old Format)
              else {
                const newText = note.text.replace(
                  searchState.query,
                  searchState.replaceText
                );
                newNotes = notesData.map((n) =>
                  n.id === currentId ? { ...n, text: newText } : n
                );
              }

              updateNotesWithHistory(newNotes);
            }
          }
        };

        const handleReplaceAll = () => {
          if (!searchState.query) return;

          if (viewMode === "map") {
            // Map Logic (Unchanged)
            const isNodeHidden = (nodeId, allNodes) => {
              const node = allNodes.find((n) => n.id === nodeId);
              if (!node || !node.parentId) return false;
              const parent = allNodes.find((n) => n.id === node.parentId);
              if (parent && parent.isCollapsed) return true;
              return isNodeHidden(node.parentId, allNodes);
            };

            const newNodes = nodes.map((n) => {
              if (isNodeHidden(n.id, nodes)) return n;
              return {
                ...n,
                text: n.text
                  ? n.text.replaceAll(
                      searchState.query,
                      searchState.replaceText
                    )
                  : n.text,
              };
            });
            updateNodesWithHistory(newNodes);
          } else {
            // Notes Logic (Updated for Blocks)
            const newNotes = notesData.map((n) => {
              // Case A: Blocks
              if (n.blocks && n.blocks.length > 0) {
                const newBlocks = n.blocks.map((block) => {
                  if (block.type === "text") {
                    return {
                      ...block,
                      content: block.content.replaceAll(
                        searchState.query,
                        searchState.replaceText
                      ),
                    };
                  }
                  return block;
                });

                const newLegacyText = newBlocks
                  .map((b) => {
                    if (b.type === "text") return b.content;
                    if (b.type === "table") {
                      if (b.data) {
                        const headers = `| ${b.data.headers.join(" | ")} |`;
                        const rows = b.data.rows
                          .map((row) => `| ${row.join(" | ")} |`)
                          .join("\n");
                        return `${headers}\n${rows}`;
                      }
                      return "[Table]";
                    }
                    return "";
                  })
                  .join("\n\n");

                return { ...n, blocks: newBlocks, text: newLegacyText };
              }
              // Case B: Legacy
              return {
                ...n,
                text: n.text
                  ? n.text.replaceAll(
                      searchState.query,
                      searchState.replaceText
                    )
                  : n.text,
              };
            });
            updateNotesWithHistory(newNotes);
          }
        };

        // --- LOGIC: EXPAND / COLLAPSE OPTIONS ---

        const handleGlobalToggle = () => {
          const anyCollapsed = nodes.some(
            (n) => n.id !== "root" && n.isCollapsed
          );
          let newNodes;
          if (anyCollapsed) {
            newNodes = nodes.map((n) => ({ ...n, isCollapsed: false }));
          } else {
            newNodes = nodes.map((n) =>
              n.id === "root" ? n : { ...n, isCollapsed: true }
            );
          }
          updateNodesWithHistory(newNodes);
        };

        const handleSubtreeToggle = () => {
          if (!selectedNodeId) return;
          const getDescendantIds = (parentId, allNodes) => {
            let ids = [];
            allNodes.forEach((n) => {
              if (n.parentId === parentId) {
                ids.push(n.id);
                ids = [...ids, ...getDescendantIds(n.id, allNodes)];
              }
            });
            return ids;
          };
          const descendantIds = getDescendantIds(selectedNodeId, nodes);
          const branchIds = [selectedNodeId, ...descendantIds];
          const isNotFullyExpanded = nodes.some(
            (n) => branchIds.includes(n.id) && n.isCollapsed
          );

          const newNodes = nodes.map((n) => {
            if (branchIds.includes(n.id)) {
              return { ...n, isCollapsed: !isNotFullyExpanded }; // Expand or Collapse based on state
            }
            return n;
          });
          updateNodesWithHistory(newNodes);
        };

        // Connect this to your Toolbar Button onClick
        const handleToolbarExpandCollapse = () => {
          if (!selectedNodeId) {
            alert("Please select a node to Expand/Collapse, Ji!");
            return;
          }

          if (selectedNodeId === "root") {
            handleGlobalToggle();
          } else {
            handleSubtreeToggle();
          }
        };

        // --- KEYBOARD SHORTCUTS ---
        useEffect(() => {
          const handleActionShortcuts = (e) => {
            const isCtrlShift = (e.ctrlKey || e.metaKey) && e.shiftKey;

            // 1. Add Node: Ctrl + Shift + A
            if (isCtrlShift && e.key.toLowerCase() === "a") {
              e.preventDefault();
              addNode();
            }

            // 2. Delete Node: Ctrl + Shift + D
            if (isCtrlShift && e.key.toLowerCase() === "d") {
              e.preventDefault();
              deleteNode();
            }

            // 3. Global Expand/Collapse: Ctrl + Shift + X
            if (isCtrlShift && e.key.toLowerCase() === "x") {
              e.preventDefault();
              handleToolbarExpandCollapse();
            }

            // 4. Switch View: Ctrl + Shift + S
            if (isCtrlShift && e.key.toLowerCase() === "s") {
              e.preventDefault();
              handleSwitchView(viewMode === "map" ? "notes" : "map");
            }

            // 5. Toggle Shortcuts: Ctrl + /
            if ((e.ctrlKey || e.metaKey) && e.key === "/") {
              e.preventDefault();
              setShowShortcuts((prev) => !prev);
            }

            // --- LEVEL-BY-LEVEL SHORTCUTS (FIXED) ---

            // 6. Expand Next Level: Ctrl + Shift + {
            if (isCtrlShift && e.key === "{") {
              e.preventDefault();
              e.stopPropagation();
              if (viewMode === "map") {
                // Yahan check karo ki function exist karta hai ya nahi
                if (typeof expandNextLevel === "function") {
                  expandNextLevel(selectedNodeId || "root");
                }
              }
            }

            // 7. Collapse One Level: Ctrl + Shift + }
            if (isCtrlShift && e.key === "}") {
              e.preventDefault();
              e.stopPropagation();
              if (viewMode === "map") {
                if (typeof collapseOneLevel === "function") {
                  collapseOneLevel(selectedNodeId || "root");
                }
              }
            }
          };

          window.addEventListener("keydown", handleActionShortcuts);
          return () =>
            window.removeEventListener("keydown", handleActionShortcuts);
        }, [
          // IMPORTANT: Dependency Array mein saare variables hone chahiye
          addNode,
          deleteNode,
          handleToolbarExpandCollapse,
          viewMode,
          handleSwitchView,
          selectedNodeId,
          expandNextLevel, // <--- Yeh hona zaroori hai!
          collapseOneLevel, // <--- Yeh bhi!
        ]);

        return (
          <div className="flex h-screen w-full overflow-hidden text-slate-800 bg-slate-50">
            {/* SIDEBAR NAVIGATION */}
            <div className="w-20 bg-white border-r border-slate-200 flex flex-col items-center py-6 gap-6 z-20 shadow-sm">
              <div className="w-10 h-10 bg-blue-600 rounded-xl flex items-center justify-center text-white font-bold text-lg mb-4">
                M
              </div>

              <button
                onClick={() => handleSwitchView("map")} // <--- UPDATED
                className={`p-3 rounded-xl transition-all ${
                  viewMode === "map"
                    ? "bg-blue-50 text-blue-600"
                    : "text-slate-400 hover:bg-slate-50"
                }`}
                title="Mind Map Canvas"
              >
                <MapIcon />
              </button>

              <button
                onClick={() => handleSwitchView("notes")} // <--- UPDATED
                className={`p-3 rounded-xl transition-all ${
                  viewMode === "notes"
                    ? "bg-blue-50 text-blue-600"
                    : "text-slate-400 hover:bg-slate-50"
                }`}
                title="Notes Page"
              >
                <NotesIcon />
              </button>
            </div>

            {/* MAIN CONTENT AREA */}
            <div className="flex-1 flex flex-col h-full overflow-hidden relative">
              {viewMode === "map" ? (
                <>
                  {/* TOOLBAR (MAP) */}
                  <div className="h-16 bg-white border-b border-slate-200 flex items-center justify-between px-6 shadow-sm z-10 relative">
                    <div className="flex items-center gap-4">
                      <input
                        type="file"
                        ref={fileInputRef}
                        onChange={handleFileUpload}
                        className="hidden"
                        accept="image/*"
                      />
                      <input
                        type="file"
                        ref={projectInputRef}
                        onChange={handleLoadProject}
                        className="hidden"
                        accept=".json"
                      />

                      <div className="flex items-center gap-2 bg-slate-100 rounded-full px-3 py-1.5 border border-slate-200">
                        <SingleIcon />
                        <input
                          type="color"
                          value={nodeColor}
                          onChange={(e) => updateSingleColor(e.target.value)}
                          className="w-6 h-6 rounded cursor-pointer border-none bg-transparent p-0"
                        />
                        <input
                          type="text"
                          value={nodeColor}
                          onChange={(e) => updateSingleColor(e.target.value)}
                          className="w-16 text-xs font-mono bg-transparent border-none focus:outline-none text-slate-600 uppercase"
                          maxLength={7}
                        />
                      </div>

                      <div className="flex items-center gap-2 bg-slate-100 rounded-full px-3 py-1.5 border border-slate-200">
                        <GroupIcon />
                        <input
                          type="color"
                          value={nodeColor}
                          onChange={(e) => updateGroupColor(e.target.value)}
                          className="w-6 h-6 rounded cursor-pointer border-none bg-transparent p-0"
                        />
                        <input
                          type="text"
                          value={nodeColor}
                          onChange={(e) => updateGroupColor(e.target.value)}
                          className="w-16 text-xs font-mono bg-transparent border-none focus:outline-none text-slate-600 uppercase"
                          maxLength={7}
                        />
                      </div>

                      <div className="flex items-center gap-2 bg-slate-100 rounded-full px-3 py-1.5 border border-slate-200">
                        <PaletteIcon />
                        <input
                          type="color"
                          value={nodeColor}
                          onChange={(e) => updateLevelColor(e.target.value)}
                          className="w-6 h-6 rounded cursor-pointer border-none bg-transparent p-0"
                        />
                        <input
                          type="text"
                          value={nodeColor}
                          onChange={(e) => updateLevelColor(e.target.value)}
                          className="w-16 text-xs font-mono bg-transparent border-none focus:outline-none text-slate-600 uppercase"
                          maxLength={7}
                        />
                      </div>

                      <div className="flex items-center gap-1 bg-slate-100 rounded-full px-2 py-1.5 border border-slate-200">
                        <button
                          onClick={() => openStyleDialog("outline")}
                          className="p-1.5 rounded-full hover:bg-white hover:shadow-sm text-slate-600 transition-all"
                          title="Outlined Background"
                        >
                          <SquareIcon />
                        </button>
                        <div className="w-px h-4 bg-slate-300"></div>
                        <button
                          onClick={() => openStyleDialog("filled")}
                          className="p-1.5 rounded-full hover:bg-white hover:shadow-sm text-slate-600 transition-all"
                          title="Filled Background"
                        >
                          <FilledSquareIcon />
                        </button>
                      </div>

                      <div className="flex items-center gap-1 bg-slate-100 rounded-full px-2 py-1.5 border border-slate-200">
                        <button
                          onClick={moveNodeUp}
                          className="p-1.5 rounded-full hover:bg-white hover:shadow-sm text-slate-600 transition-all"
                          title="Move Up"
                        >
                          <ArrowUpIcon />
                        </button>
                        <button
                          onClick={moveNodeDown}
                          className="p-1.5 rounded-full hover:bg-white hover:shadow-sm text-slate-600 transition-all"
                          title="Move Down"
                        >
                          <ArrowDownIcon />
                        </button>
                      </div>

                      <button
                        onClick={startMoveNode}
                        disabled={!selectedNodeId}
                        className={`p-2 rounded-full transition-colors ${
                          selectedNodeId && selectedNodeId !== "root"
                            ? "text-blue-500 hover:bg-blue-50"
                            : "text-slate-300 cursor-not-allowed"
                        }`}
                        title="Move Branch (Change Parent)"
                      >
                        <MoveIcon />
                      </button>

                      <button
                        onClick={handleSaveProject}
                        className="p-2 text-slate-600 hover:bg-slate-100 rounded-full transition-colors"
                        title="Save Project"
                      >
                        <SaveIcon />
                      </button>
                      <button
                        onClick={handleOpenProjectPicker}
                        className="p-2 text-slate-600 hover:bg-slate-100 rounded-full transition-colors"
                        title="Open Project"
                      >
                        <FolderOpenIcon />
                      </button>

                      <button
                        onClick={handleToolbarExpandCollapse}
                        className={`p-2 rounded-full transition-colors ${
                          selectedNodeId
                            ? "text-slate-600 hover:bg-slate-100"
                            : "text-slate-300 cursor-not-allowed"
                        }`}
                        title="Expand/Collapse Branch"
                        disabled={!selectedNodeId}
                      >
                        <ExpandIcon />
                      </button>

                      <div className="h-6 w-px bg-slate-300 mx-2"></div>
                      <button
                        onClick={() => fileInputRef.current.click()}
                        className="flex items-center gap-2 px-4 py-2 bg-slate-100 hover:bg-slate-200 text-slate-700 rounded-full text-sm font-medium"
                      >
                        {isProcessing ? <LoaderIcon /> : <UploadIcon />}{" "}
                        {isProcessing ? "Analyzing..." : "Import Image"}
                      </button>

                      <div className="h-6 w-px bg-slate-300 mx-2"></div>
                      <button
                        onClick={addNode}
                        className="flex items-center gap-2 px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-full shadow-md hover:shadow-lg transition-all text-sm font-medium"
                      >
                        <PlusIcon /> Add Node
                      </button>
                      <button
                        onClick={deleteNode}
                        disabled={!selectedNodeId}
                        className={`p-2 rounded-full transition-colors ${
                          selectedNodeId
                            ? "text-red-500 hover:bg-red-50"
                            : "text-slate-300 cursor-not-allowed"
                        }`}
                      >
                        <TrashIcon />
                      </button>

                      <div className="flex items-center bg-slate-50 rounded-full p-1 border border-slate-200 shadow-inner">
                        <div className="px-2.5 py-1 text-slate-400 border-r border-slate-200 flex items-center justify-center">
                          {isDownloading ? (
                            <svg
                              className="animate-spin h-4 w-4"
                              viewBox="0 0 24 24"
                            >
                              <circle
                                className="opacity-25"
                                cx="12"
                                cy="12"
                                r="10"
                                stroke="currentColor"
                                strokeWidth="4"
                                fill="none"
                              ></circle>
                              <path
                                className="opacity-75"
                                fill="currentColor"
                                d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                              ></path>
                            </svg>
                          ) : (
                            <svg
                              xmlns="[http://www.w3.org/2000/svg](http://www.w3.org/2000/svg)"
                              width="16"
                              height="16"
                              viewBox="0 0 24 24"
                              fill="none"
                              stroke="currentColor"
                              strokeWidth="2.5"
                              strokeLinecap="round"
                              strokeLinejoin="round"
                            >
                              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
                              <polyline points="7 10 12 15 17 10" />
                              <line x1="12" x2="12" y1="15" y2="3" />
                            </svg>
                          )}
                        </div>
                        <button
                          onClick={() => handleDownloadMindMap("png")}
                          disabled={isDownloading}
                          className="px-3 py-1.5 text-[10px] font-black text-slate-500 hover:text-blue-600 hover:bg-white rounded-full transition-all flex items-center justify-center min-w-[40px]"
                          title="Export as PNG (Image)"
                        >
                          PNG
                        </button>
                        <div className="w-px h-3 bg-slate-200"></div>
                        <button
                          onClick={() => handleDownloadMindMap("svg")}
                          disabled={isDownloading}
                          className="px-3 py-1.5 text-[10px] font-black text-blue-600 hover:text-blue-700 hover:bg-white rounded-full transition-all flex items-center justify-center min-w-[40px]"
                          title="Export as SVG (Searchable Text)"
                        >
                          SVG
                        </button>
                      </div>
                    </div>
                  </div>

                  {/* MAP SEARCH OVERLAY (Only visible via Shortcut in Map Mode) */}
                  {showSearch && viewMode === "map" && (
                    <div className="absolute top-20 right-10 z-50 w-96 bg-white/95 backdrop-blur p-3 rounded-xl shadow-2xl border border-slate-200 animate-fade-in">
                      <div className="flex flex-col gap-2">
                        <div className="flex items-center bg-slate-50 rounded-lg px-2 border border-slate-200">
                          <SearchIcon />
                          <input
                            type="text"
                            placeholder="Find node..."
                            value={searchState.query}
                            onChange={(e) =>
                              setSearchState((prev) => ({
                                ...prev,
                                query: e.target.value,
                              }))
                            }
                            // UPDATED: Simple autoFocus=true is best here for "as soon as open" behavior
                            // React handles autoFocus on mount reliably.
                            autoFocus={true}
                            className="bg-transparent border-none focus:outline-none text-sm ml-2 w-full py-2"
                          />
                          <span className="text-xs text-slate-400 font-mono whitespace-nowrap px-2 border-l border-slate-200">
                            {searchState.matches.length > 0
                              ? `${searchState.currentIndex + 1}/${
                                  searchState.matches.length
                                }`
                              : "0/0"}
                          </span>
                          <div className="flex gap-1 ml-1">
                            <button
                              onClick={handleSearchPrev}
                              className="p-1 hover:bg-slate-200 rounded text-slate-600"
                            >
                              <ChevronLeftIcon />
                            </button>
                            <button
                              onClick={handleSearchNext}
                              className="p-1 hover:bg-slate-200 rounded text-slate-600"
                            >
                              <ChevronRightIcon />
                            </button>
                          </div>
                        </div>
                        {/* ... (Replace UI unchanged) ... */}
                        <div className="flex gap-2">
                          <div className="flex items-center bg-slate-50 rounded-lg px-2 border border-slate-200 flex-1">
                            <span className="text-[10px] font-bold text-slate-400 mr-2">
                              REP
                            </span>
                            <input
                              type="text"
                              placeholder="Replace..."
                              value={searchState.replaceText}
                              onChange={(e) =>
                                setSearchState((prev) => ({
                                  ...prev,
                                  replaceText: e.target.value,
                                }))
                              }
                              className="bg-transparent border-none focus:outline-none text-sm w-full py-1.5"
                            />
                          </div>
                          <button
                            onClick={handleReplace}
                            className="px-3 bg-blue-50 text-blue-600 text-xs font-bold rounded hover:bg-blue-100"
                          >
                            One
                          </button>
                          <button
                            onClick={handleReplaceAll}
                            className="px-3 bg-slate-100 text-slate-600 text-xs font-bold rounded hover:bg-slate-200"
                          >
                            All
                          </button>
                        </div>
                        <button
                          onClick={handleCloseSearch}
                          className="absolute -top-2 -right-2 bg-white rounded-full p-1 shadow border border-slate-100 text-slate-400 hover:text-red-500"
                        >
                          <CloseIcon />
                        </button>
                      </div>
                    </div>
                  )}

                  {/* CANVAS CONTAINER */}
                  <div
                    id="mindmap-canvas"
                    ref={canvasRef}
                    className={`flex-1 relative bg-slate-50 overflow-hidden cursor-pan ${
                      isDraggingRoot ? "cursor-grabbing" : ""
                    } ${isMoveMode ? "!cursor-crosshair bg-blue-50/30" : ""}`}
                    onMouseDown={startPan}
                    onMouseMove={doPan}
                    onMouseUp={endPan}
                    onMouseLeave={endPan}
                  >
                    {/* MOVE MODE BANNER */}
                    {isMoveMode && (
                      <div className="absolute top-4 left-1/2 transform -translate-x-1/2 z-50 bg-blue-600 text-white px-6 py-2 rounded-full shadow-lg flex items-center gap-4 animate-fade-in">
                        <span className="font-medium animate-pulse">
                          Select the New Parent Node...
                        </span>
                        <button
                          onClick={cancelMoveNode}
                          className="bg-white/20 hover:bg-white/30 rounded-full p-1"
                        >
                          <svg
                            xmlns="http://www.w3.org/2000/svg"
                            width="16"
                            height="16"
                            viewBox="0 0 24 24"
                            fill="none"
                            stroke="currentColor"
                            strokeWidth="2"
                            strokeLinecap="round"
                            strokeLinejoin="round"
                          >
                            <line x1="18" y1="6" x2="6" y2="18"></line>
                            <line x1="6" y1="6" x2="18" y2="18"></line>
                          </svg>
                        </button>
                      </div>
                    )}

                    {/* ZOOM CONTROLS */}
                    <div className="absolute bottom-6 left-6 flex flex-col gap-2 z-20">
                      <button
                        onClick={focusRoot}
                        className="p-2 bg-white rounded-lg shadow border border-slate-200 hover:bg-slate-50 text-blue-600"
                        title="Go to Home"
                      >
                        <HomeIcon />
                      </button>
                      <div className="h-px bg-slate-200 my-1"></div>
                      <button
                        onClick={() => setScale((s) => Math.min(s + 0.2, 5))}
                        className="p-2 bg-white rounded-lg shadow border border-slate-200 hover:bg-slate-50 text-slate-600"
                      >
                        <ZoomInIcon />
                      </button>
                      <button
                        onClick={() => fitView()}
                        className="p-2 bg-white rounded-lg shadow border border-slate-200 hover:bg-slate-50 text-slate-600"
                      >
                        <FitIcon />
                      </button>
                      <button
                        onClick={() => setScale((s) => Math.max(s - 0.2, 0.05))}
                        className="p-2 bg-white rounded-lg shadow border border-slate-200 hover:bg-slate-50 text-slate-600"
                      >
                        <ZoomOutIcon />
                      </button>
                      <div className="bg-white px-2 py-1 rounded text-xs text-center border border-slate-200 shadow-sm font-mono text-slate-500">
                        {Math.round(scale * 100)}%
                      </div>
                    </div>

                    {/* Grid Background */}
                    <div
                      id="canvas-bg"
                      className="absolute inset-0 opacity-40 pointer-events-none"
                      style={{
                        backgroundImage:
                          "radial-gradient(#94a3b8 1.5px, transparent 1.5px)",
                        backgroundSize: "24px 24px",
                        transform: `translate(${pan.x}px, ${pan.y}px) scale(${scale})`,
                        transformOrigin: "0 0",
                      }}
                    />

                    {/* VISIBLE CANVAS */}
                    <svg className="w-full h-full pointer-events-none">
                      <g
                        transform={`translate(${pan.x}, ${pan.y}) scale(${scale})`}
                      >
                        <MapRenderer
                          nodes={visibleNodes}
                          selectedNodeId={selectedNodeId}
                          updateNodeText={updateNodeText}
                          onNodeClick={handleNodeClickWrapper}
                          onNodeMouseDown={handleNodeMouseDown}
                          onToggleCollapse={toggleCollapse}
                          dirtyLevel1Nodes={dirtyLevel1Nodes} // <--- ADDED THIS LINE
                          disableAutoFocus={showSearch} // <--- PASSING THE FLAG HERE
                        />
                      </g>
                    </svg>

                    {/* QUICK TIPS */}
                    <div className="absolute top-6 right-6 bg-white/90 backdrop-blur p-4 rounded-xl shadow-lg border border-slate-200 max-w-xs pointer-events-none select-none">
                      <h3 className="font-bold text-slate-800 mb-2 flex items-center gap-2">
                        <div className="w-2 h-2 rounded-full bg-green-500 animate-pulse"></div>{" "}
                        Infinite Canvas
                      </h3>
                      <ul className="text-xs text-slate-600 space-y-1 list-disc pl-4">
                        <li>
                          <b>Dot Icon:</b> Color ONE Node.
                        </li>
                        <li>
                          <b>User Icon:</b> Color Siblings (Group).
                        </li>
                        <li>
                          <b>Palette:</b> Color Entire Level.
                        </li>
                      </ul>
                    </div>
                  </div>

                  {/* STYLE SELECTION DIALOG */}
                  {styleDialogOpen && (
                    <div className="fixed inset-0 bg-black/20 backdrop-blur-sm z-50 flex items-center justify-center">
                      <div className="bg-white rounded-2xl shadow-2xl p-6 w-80 animate-fade-in border border-slate-100">
                        <h3 className="text-lg font-bold text-slate-800 mb-2 text-center">
                          Change Style
                        </h3>
                        <p className="text-sm text-slate-500 text-center mb-6">
                          Apply{" "}
                          <b>
                            {pendingStyleType === "filled"
                              ? "Filled"
                              : "Outline"}
                          </b>{" "}
                          style to:
                        </p>

                        <div className="space-y-3">
                          <button
                            onClick={updateNodeStyleOnly}
                            className="w-full flex items-center gap-3 p-3 rounded-xl bg-slate-50 hover:bg-blue-50 hover:text-blue-600 transition-colors border border-slate-200 group"
                          >
                            <SingleIcon />
                            <span className="font-medium">Only This Node</span>
                          </button>
                          <button
                            onClick={updateSiblingStyle}
                            className="w-full flex items-center gap-3 p-3 rounded-xl bg-slate-50 hover:bg-blue-50 hover:text-blue-600 transition-colors border border-slate-200 group"
                          >
                            <GroupIcon />
                            <span className="font-medium">
                              All Siblings (Group)
                            </span>
                          </button>
                          <button
                            onClick={updateLevelStyle}
                            className="w-full flex items-center gap-3 p-3 rounded-xl bg-slate-50 hover:bg-blue-50 hover:text-blue-600 transition-colors border border-slate-200 group"
                          >
                            <PaletteIcon />
                            <span className="font-medium">Entire Level</span>
                          </button>
                        </div>

                        <button
                          onClick={() => setStyleDialogOpen(false)}
                          className="mt-6 w-full py-2 text-sm text-slate-400 hover:text-slate-600 font-medium"
                        >
                          Cancel
                        </button>
                      </div>
                    </div>
                  )}

                  {/* HIDDEN EXPORT CONTAINER */}
                  {isDownloading && exportConfig && (
                    <div
                      id="export-container"
                      style={{
                        position: "fixed",
                        left: 0,
                        top: 0,
                        zIndex: -100,
                        width: exportConfig.width,
                        height: exportConfig.height,
                        backgroundColor: "white",
                      }}
                    >
                      <svg
                        width={exportConfig.width}
                        height={exportConfig.height}
                      >
                        <g
                          transform={`translate(${exportConfig.offsetX}, ${exportConfig.offsetY}) scale(1)`}
                        >
                          <MapRenderer
                            nodes={visibleNodes}
                            selectedNodeId={null}
                            updateNodeText={() => {}}
                            onNodeClick={() => {}}
                            isExport={true}
                          />
                        </g>
                      </svg>
                    </div>
                  )}
                </>
              ) : (
                /* NOTES VIEW */
                <NotesView
                  notesData={notesData}
                  setNotesData={setNotesData}
                  onAddNote={addNote}
                  onUpdateNote={updateNote}
                  onDeleteNote={deleteNote}
                  onDownloadNotes={handleDownloadNotes}
                  isDownloading={isExportingNotes}
                  onMoveUp={moveNoteUpInList}
                  onMoveDown={moveNoteDownInList}
                  // NEW PROPS FOR READING MODE
                  isReadingMode={isReadingMode}
                  setIsReadingMode={setIsReadingMode}
                  showSearch={showSearch}
                  setShowSearch={setShowSearch}
                  searchState={searchState}
                  setSearchState={setSearchState}
                  handleSearchNext={handleSearchNext}
                  handleSearchPrev={handleSearchPrev}
                  handleReplace={handleReplace}
                  handleReplaceAll={handleReplaceAll}
                  onCloseSearch={handleCloseSearch}
                />
              )}

              {/* HIDDEN EXPORT CONTAINER FOR NOTES */}
              {isExportingNotes && (
                <div
                  id="notes-export-container"
                  className="fixed left-0 top-0 bg-slate-50 p-12 z-[-50] space-y-6"
                  style={{ width: "800px", height: "auto" }}
                >
                  <h2 className="text-3xl font-bold text-slate-800 mb-8">
                    My Notes
                  </h2>
                  <NotesListRenderer notesData={notesData} isExport={true} />
                </div>
              )}

              {/* 3. RENDER COMPONENT: Place this just before closing div of App */}
              <ShortcutsDialog
                isOpen={showShortcuts}
                onClose={() => setShowShortcuts(false)}
              />

              <ToastNotification
                message={toast.message}
                isVisible={toast.show}
                onClose={() => setToast({ ...toast, show: false })}
              />

              <MoveCopyDialog
                isOpen={moveCopyDialog.isOpen}
                onClose={() => {
                  setMoveCopyDialog({
                    isOpen: false,
                    sourceId: null,
                    targetId: null,
                  });
                  setIsMoveMode(false); // Cancel move mode if dialog cancelled
                  setMovingNodeId(null);
                }}
                onMove={executeMove}
                onCopy={executeCopy}
              />
            </div>
          </div>
        );
      }

      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(<App />);
    </script>
  </body>
</html>
